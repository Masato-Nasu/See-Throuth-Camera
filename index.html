<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>視覚ガイド SAFE版（まず確実に動く）</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui, -apple-system, Segoe UI, Roboto, 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif}
  #root{position:fixed;inset:0}
  video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
  #hud{position:fixed;left:0;right:0;bottom:0;background:#0b0b0cdd;backdrop-filter:blur(2px);padding:8px;display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button,select,input[type=range],label{font-size:14px}
  button{padding:8px 12px;border:0;border-radius:10px;background:#2e7d32;color:#fff}
  button.stop{background:#c62828}
  #debug{position:fixed;left:8px;top:8px;right:8px;max-height:42vh;overflow:auto;background:#0008;border:1px solid #3a3; padding:6px;border-radius:8px;font:12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre-wrap}
  .badge{display:inline-block;padding:2px 6px;border-radius:6px;background:#111;border:1px solid #444;margin-right:6px}
</style>
</head>
<body>
<div id="root">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="view"></canvas>
</div>

<div id="debug"></div>

<div id="hud">
  <button id="btn">開始</button>
  <label><input type="checkbox" id="chkTactile"> 点字ブロック検出（負荷あり）</label>
  <label>最大件数 <input type="range" id="maxItems" min="1" max="8" value="4"></label>
  <span class="badge" id="badge">準備中…</span>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
<script src="https://docs.opencv.org/4.x/opencv.js" async></script>
<script>
const logEl = document.getElementById('debug');
function log(){ const t = new Date().toLocaleTimeString(); logEl.textContent += `[${t}] ` + Array.from(arguments).join(' ') + '\\n'; logEl.scrollTop = logEl.scrollHeight; }
const badge = document.getElementById('badge');
const btn = document.getElementById('btn');
const chkTactile = document.getElementById('chkTactile');
const maxItems = document.getElementById('maxItems');

const video = document.getElementById('video');
const view = document.getElementById('view');
const ctx = view.getContext('2d');

let running=false, model=null, cvReady=false;

// Ensure tfjs backend
(async()=>{
  try{
    if(tf && tf.setBackend){
      await tf.setBackend('webgl').catch(async e=>{ log('webgl backend failed, fallback to cpu'); await tf.setBackend('cpu'); });
      await tf.ready();
      log('TFJS backend:', tf.getBackend());
    }
  }catch(e){ log('TFJS init error:', e); }
})();

// OpenCV ready promise
const cvReadyPromise = new Promise(res=>{
  if (window.cv && cv.getBuildInformation) {
    cv['onRuntimeInitialized'] = ()=>{ cvReady=true; log('OpenCV ready'); res(); };
  } else {
    window.Module = { onRuntimeInitialized() { cvReady=true; log('OpenCV ready'); res(); } };
  }
});

async function initCamera(){
  const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment', width:{ideal:1280}, height:{ideal:720} }, audio:false });
  video.srcObject = stream;
  await video.play();
  resize();
  log('Camera initialized', video.videoWidth+'x'+video.videoHeight);
}
function resize(){
  view.width = video.videoWidth || view.clientWidth;
  view.height = video.videoHeight || view.clientHeight;
}
window.addEventListener('resize', resize);

// TTS
function speakJa(text){
  try{
    const u = new SpeechSynthesisUtterance(text.replaceAll('方向','ほうこう').replaceAll('信号','しんごう'));
    u.lang='ja-JP'; speechSynthesis.cancel(); speechSynthesis.speak(u);
  }catch(e){ log('TTS error', e); }
}

// Simple bearing (1~12 o'clock)
function bearingLabel(cx, cy, W, H){
  const dx = cx - W/2, dy = H/2 - cy;
  let deg = (Math.atan2(dy, dx)*180/Math.PI + 360) % 360;
  const hour = Math.round(deg/30) || 12;
  return `${hour}じ`;
}
// Heuristic distance
function estDistanceMeters(w,h,W,H){
  const areaRatio = (w*h)/(W*H);
  return Math.min(10, Math.max(0.3, 0.6/Math.sqrt(Math.max(areaRatio,1e-6))));
}

// Tactile detection (simplified + guarded)
function detectTactileSimple(srcRGBA){
  if(!cvReady) return [];
  let gray = new cv.Mat();
  cv.cvtColor(srcRGBA, gray, cv.COLOR_RGBA2GRAY);
  let mean = cv.mean(gray)[0]; gray.delete();
  if(mean < 40) return [];

  let rgb=new cv.Mat(); cv.cvtColor(srcRGBA,rgb,cv.COLOR_RGBA2RGB);
  let hsv=new cv.Mat(); cv.cvtColor(rgb,hsv,cv.COLOR_RGB2HSV); rgb.delete();
  let lo=new cv.Mat(hsv.rows,hsv.cols,hsv.type(), [18,140,120,0]);
  let hi=new cv.Mat(hsv.rows,hsv.cols,hsv.type(), [36,255,255,255]);
  let mask=new cv.Mat(); cv.inRange(hsv,lo,hi,mask); lo.delete(); hi.delete(); hsv.delete();

  // bottom 40%
  const h = mask.rows, w = mask.cols;
  const floorH = Math.floor(h*0.4);
  let roiMask = new cv.Mat.zeros(h,w,cv.CV_8UC1);
  roiMask.roi(new cv.Rect(0,h-floorH,w,floorH)).setTo(new cv.Scalar(255));
  cv.bitwise_and(mask,roiMask,mask); roiMask.delete();

  // morphology
  let k = cv.Mat.ones(5,5,cv.CV_8U);
  cv.morphologyEx(mask,mask,cv.MORPH_OPEN,k);
  cv.morphologyEx(mask,mask,cv.MORPH_CLOSE,k); k.delete();

  let contours=new cv.MatVector(), hier=new cv.Mat();
  cv.findContours(mask,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
  mask.delete(); hier.delete();

  let out=[];
  for(let i=0;i<contours.size();i++){
    let r = cv.boundingRect(contours.get(i));
    const ar = (r.width*r.height)/(w*h);
    const aspect = r.width>r.height ? r.width/(r.height+1e-6) : r.height/(r.width+1e-6);
    if(ar>0.002 && ar<0.2 && aspect>1.2 && aspect<6.0){
      out.push(r);
    }
  }
  contours.delete();
  return out;
}

let offscreen = document.createElement('canvas');
let ofx = offscreen.getContext('2d');

async function runLoop(){
  if(!running) return;
  resize();
  const W=view.width, H=view.height;
  ctx.drawImage(video,0,0,W,H);

  // downscale for detection
  const infW=320, infH=Math.floor(H*(320/W));
  offscreen.width=infW; offscreen.height=infH;
  ofx.drawImage(video,0,0,infW,infH);

  let t0=performance.now();
  let detections = [];
  try{
    detections = await model.detect(offscreen);
  }catch(e){ log('detect error:', e); }
  let t1=performance.now();

  // draw
  detections.sort((a,b)=>b.score-a.score);
  detections = detections.slice(0, parseInt(maxItems.value,10));
  ctx.lineWidth = 3; ctx.font = `${Math.max(14, Math.floor(W*0.032))}px system-ui`;
  let said = false;
  for(const p of detections){
    if(p.score<0.55) continue;
    const scaleX = W/infW, scaleY = H/infH;
    let [x,y,w,h]=p.bbox;
    x*=scaleX; y*=scaleY; w*=scaleX; h*=scaleY;
    ctx.strokeStyle='rgba(0,255,0,.9)'; ctx.fillStyle='rgba(0,0,0,.55)';
    ctx.strokeRect(x,y,w,h);
    const name = ({'person':'人','bicycle':'自転車','car':'車','bus':'バス','motorcycle':'バイク','truck':'トラック',
                   'laptop':'ノートパソコン','mouse':'マウス','backpack':'リュックサック','traffic light':'信号機'})[p.class] || p.class;
    const angle = bearingLabel(x+w/2,y+h/2,W,H);
    const dist = estDistanceMeters(w,h,W,H);
    const label = `${angle} ほうこう  ${name}  ${dist.toFixed(1)}m`;
    const tw = ctx.measureText(label).width + 10;
    ctx.fillRect(x, Math.max(0,y-24), tw, 24);
    ctx.fillStyle='#9cff9c'; ctx.fillText(label, x+5, y-6);
    if(!said){ speakJa(`${angle} ほうこう ${name} ${dist.toFixed(1)}メートル`); said=true; }
  }

  // tactile (optional)
  if(chkTactile.checked){
    try{
      const src=cv.imread(view);
      const boxes=detectTactileSimple(src);
      src.delete();
      ctx.strokeStyle='#ffa726'; ctx.lineWidth=5; ctx.fillStyle='rgba(0,0,0,.55)';
      for(const b of boxes){
        ctx.strokeRect(b.x,b.y,b.width,b.height);
        const label='点字ブロック';
        const tw=ctx.measureText(label).width+10;
        ctx.fillRect(b.x, Math.max(0,b.y-24), tw, 24);
        ctx.fillStyle='#ffd27f'; ctx.fillText(label, b.x+5, b.y-6);
      }
    }catch(e){ log('tactile error:', e); }
  }

  const fps = (1000/(performance.now()-t0)).toFixed(1);
  badge.textContent = `FPS:${fps} / det:${(t1-t0).toFixed(0)}ms`;
  if(running) requestAnimationFrame(runLoop);
}

btn.onclick = async ()=>{
  if(!running){
    running = true; btn.textContent='停止'; btn.classList.add('stop');
    requestAnimationFrame(runLoop);
  }else{
    running = false; btn.textContent='開始'; btn.classList.remove('stop');
  }
};

(async function bootstrap(){
  try{
    badge.textContent = 'カメラ起動中…（許可してください）'; await initCamera();
    badge.textContent = 'モデル読込中…'; model = await cocoSsd.load();
    badge.textContent = 'OpenCV初期化中…'; await cvReadyPromise;
    badge.textContent = '準備完了：開始で実行／点字はチェックをON';
    log('準備完了。動作が重い場合は点字検出のチェックを外してください。');
  }catch(e){
    log('初期化エラー:', e); badge.textContent='エラー：詳細は上のログ';
  }
})();
</script>
</body>
</html>
