<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>AR 思考ストリーム — カメラ背景 + 緑ネオン + 物体認識/距離(概算)</title>
  <!-- TF.js & COCO-SSD (物体検出) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.19.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
  <style>
    :root{
      --bg: #000;
      --hud: rgba(0, 0, 0, 0.25);
      --grid: rgba(0, 255, 128, 0.12);
      --green: #39ff14; /* ネオン系グリーン */
      --text: #d7ffd7;
    }
    html, body { margin:0; height:100%; background:var(--bg); color:var(--text); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; overflow:hidden; }

    /* カメラ映像 */
    #camWrap { position: fixed; inset: 0; overflow: hidden; }
    #video { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; filter:saturate(1.1) contrast(1.05) brightness(1.05); transform: scaleX(-1); }

    /* 物体検出オーバーレイ */
    #overlay { position:absolute; inset:0; pointer-events:none; }

    /* HUDパネル */
    #hud { position: fixed; inset: 0; pointer-events: none; }
    .panel { position:absolute; left:50%; transform:translateX(-50%); bottom:6vh; width:min(1000px,92vw); height:52vh; background: linear-gradient(180deg, rgba(0,0,0,0.15), rgba(0,0,0,0.35)); border: 1px solid rgba(57,255,20,0.35); border-radius: 16px; box-shadow: 0 0 24px rgba(57,255,20,0.12), inset 0 0 40px rgba(57,255,20,0.06); backdrop-filter: blur(6px) saturate(1.1); -webkit-backdrop-filter: blur(6px) saturate(1.1); overflow:hidden; }
    .panel::before{ content:""; position:absolute; inset:0; background: repeating-linear-gradient(to bottom, rgba(0,255,128,0.05), rgba(0,255,128,0.05) 2px, transparent 2px, transparent 6px); mix-blend-mode: screen; pointer-events:none; animation: scan 5s linear infinite; }
    @keyframes scan{ from{ transform: translateY(-10%);} to{ transform: translateY(10%);} }
    .panel::after{ content:""; position:absolute; inset:0; background: linear-gradient(var(--grid) 1px, transparent 1px), linear-gradient(90deg, var(--grid) 1px, transparent 1px); background-size: 32px 32px, 32px 32px; mask-image: linear-gradient(to top, transparent, rgba(0,0,0,0.6) 30%, rgba(0,0,0,0.9)); pointer-events:none; }
    .title { position:absolute; inset:0 0 auto 0; height:42px; background: linear-gradient(90deg, rgba(57,255,20,0.2), rgba(57,255,20,0), rgba(57,255,20,0.2)); border-bottom:1px solid rgba(57,255,20,0.35); display:flex; align-items:center; padding:0 16px; font-weight:600; letter-spacing:.06em; color:var(--green); text-shadow:0 0 8px rgba(57,255,20,.8), 0 0 18px rgba(57,255,20,.4); }
    #stream { position:absolute; top:50px; bottom:82px; left:0; right:0; padding: 14px 16px 24px; overflow:hidden; font-size: clamp(12px, 1.9vw, 16px); line-height: 1.6; color: var(--text); }
    .line { opacity:.95; margin:2px 0; white-space:pre-wrap; word-break:break-word; text-shadow: 0 0 10px rgba(57,255,20,.55), 0 0 28px rgba(57,255,20,.35); }
    .cursor::after{ content:"▌"; animation: blink 1s steps(1, start) infinite; color: var(--green);} @keyframes blink { 50%{ opacity:0; } }

    #controls { position:absolute; inset:auto 0 0 0; height:82px; display:flex; flex-wrap:wrap; gap:8px; align-items:center; padding:8px 10px; background: linear-gradient(0deg, rgba(0,0,0,0.55), rgba(0,0,0,0.15)); border-top: 1px solid rgba(57,255,20,0.25); pointer-events:auto; }
    .btn { border:1px solid rgba(57,255,20,.55); background: rgba(0,0,0,.25); color: var(--green); padding:8px 12px; border-radius:10px; font-weight:600; letter-spacing:.04em; cursor:pointer; box-shadow: 0 0 12px rgba(57,255,20,.25) inset; }
    .input, .range { border:1px solid rgba(57,255,20,.35); background: rgba(0,0,0,.25); color: var(--text); border-radius:8px; padding:6px 10px; }
    .label { color: var(--green); font-size:12px; margin:0 6px 0 4px; opacity:.9; }

    #gate { position:fixed; inset:0; display:grid; place-items:center; background: radial-gradient(1200px 600px at center, rgba(0,0,0,0.6), rgba(0,0,0,0.92)); color:var(--text); z-index:10; text-align:center; padding:24px; }
    #gate .start{ font-size:18px; padding:12px 20px; border-radius:14px; cursor:pointer; border:1px solid rgba(57,255,20,.6); background: rgba(0,0,0,.35); color: var(--green); text-shadow:0 0 10px rgba(57,255,20,.9); }

    @media (max-width: 640px){ .panel{ height: 58vh; } #controls{ height: 96px; } #stream{ bottom: 96px; } }
  </style>
  <meta name="description" content="視覚支援モード（音声案内・ビープ・振動）つき実験的ARアプリ。黄線ガイド/信号色推定対応。" />
</head>
<body>
  <div id="toast" style="position:fixed;left:50%;transform:translateX(-50%);top:10px;padding:8px 12px;border:1px solid rgba(57,255,20,.5);border-radius:10px;background:rgba(0,0,0,.55);color:#39ff14;font:12px ui-monospace;z-index:20;display:none"></div>
  <div id="camWrap">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="hud">
    <div class="panel" id="panel">
      <div class="title">AI THOUGHT STREAM — SENSOR FUSION / OBJECTS / RANGE(EST.)</div>
      <div id="stream"></div>
      <div id="controls">
        <button class="btn" id="btnToggle">▶︎ START</button>
        <button class="btn" id="btnClear">CLEAR</button>
        <span class="label">Text rate</span>
        <input class="range" id="rate" type="range" min="5" max="60" value="14" />
        <span class="label">Typing</span>
        <input class="range" id="typing" type="range" min="15" max="120" value="55" />
        <span class="label">Max lines</span>
        <input class="range" id="maxlines" type="range" min="20" max="300" value="120" />
        <span class="label">Detect</span>
        <input id="detectOn" type="checkbox" checked />
        <span class="label">FOV°</span>
        <input class="range" id="fov" type="range" min="45" max="85" value="60" />
        <span class="label">Intvl(ms)</span>
        <input class="range" id="detInt" type="range" min="200" max="1500" value="650" />
        <input class="input" id="prompt" placeholder="環境メモ / キーワード（任意）" />
      </div>
    </div>
  </div>

  <div id="gate">
    <div>
      <h2 style="margin:0 0 10px 0;color:var(--green);text-shadow:0 0 16px rgba(57,255,20,.9)">カメラへのアクセスが必要です</h2>
      <p style="margin:0 0 16px 0">「開始」を押すと、背面カメラ映像にネオン緑の思考ストリームと物体検出を重ねます。</p>
      <button class="start" id="gateStart">開始 / START</button>
      <small>※距離は単眼推定の概算（対象の平均サイズとFOV仮定による）。</small>
    </div>
  </div>

<script>
  // ====== カメラ & オーバーレイ初期化 ======
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const octx = overlay.getContext('2d');

  function showToast(msg){ const t=document.getElementById('toast'); t.textContent=msg; t.style.display='block'; clearTimeout(showToast._timer); showToast._timer=setTimeout(()=>{ t.style.display='none'; }, 2500); }

  async function startCamera(){
    if (!window.isSecureContext) { showToast('⚠ HTTPSが必要です'); throw new Error('Insecure context'); }
    const v = document.getElementById('video'); v.setAttribute('playsinline','');
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' } }, audio:false });
      v.srcObject = stream; await new Promise(res=>{ v.onloadedmetadata=res; }); await v.play(); resizeOverlay(); window.addEventListener('resize', resizeOverlay); showToast('📷 カメラ起動');
    }catch(err){ console.error(err); showToast('❌ カメラ失敗: '+err.message); alert('カメラにアクセスできませんでした:
'+err.name+': '+err.message); throw err; }
  }
  function resizeOverlay(){ overlay.width = video.clientWidth || window.innerWidth; overlay.height = video.clientHeight || window.innerHeight; }(){ overlay.width = video.clientWidth; overlay.height = video.clientHeight; }

  // ====== HUD・UI ======
  const panelEl = document.getElementById('panel');
  const streamEl = document.getElementById('stream');
  const btnToggle = document.getElementById('btnToggle');
  const btnClear  = document.getElementById('btnClear');
  const rateEl    = document.getElementById('rate');     // 行/分
  const typingEl  = document.getElementById('typing');   // タイプ刻み(ms)
  const maxLinesEl= document.getElementById('maxlines');
  const detectOnEl= document.getElementById('detectOn');
  const fovEl     = document.getElementById('fov');
  const detIntEl  = document.getElementById('detInt');

  // ====== センサー ======
  const sensors = { motion:null, orientation:null, geo:null };
  function setupSensors(){
    if (window.DeviceMotionEvent){
      window.addEventListener('devicemotion', (e)=>{
        sensors.motion = { ax:e.accelerationIncludingGravity?.x??0, ay:e.accelerationIncludingGravity?.y??0, az:e.accelerationIncludingGravity?.z??0 };
      }, {passive:true});
    }
    if (window.DeviceOrientationEvent){
      window.addEventListener('deviceorientation', (e)=>{ sensors.orientation = { alpha:e.alpha, beta:e.beta, gamma:e.gamma }; }, {passive:true});
    }
    if (navigator.geolocation){ navigator.geolocation.getCurrentPosition((pos)=>{ sensors.geo = { lat: pos.coords.latitude.toFixed(5), lon: pos.coords.longitude.toFixed(5) }; }, ()=>{}, { maximumAge:60000, timeout:3000 }); }
  }
  function sensorSummary(){
    const p=[]; if (sensors.geo) p.push(`GPS ${sensors.geo.lat},${sensors.geo.lon}`); if (sensors.motion) p.push(`acc x:${sensors.motion.ax?.toFixed(1)} y:${sensors.motion.ay?.toFixed(1)} z:${sensors.motion.az?.toFixed(1)}`); if (sensors.orientation) p.push(`ori α:${sensors.orientation.alpha?.toFixed(0)} β:${sensors.orientation.beta?.toFixed(0)} γ:${sensors.orientation.gamma?.toFixed(0)}`); return p.join(' | ');
  }

  // ====== 思考ストリーム（遅め＆可変） ======
  let running=false; let loopTimer=null;
  const seedPhrases = [
    '光量チェック… エッジ低→暗所補正',
    '環境雑音: 低 // 推定',
    '位置推定: Tokyo 近傍?',
    '問いの輪郭抽出中…',
    '類似事例=3件 / confidence=0.62',
    '曖昧さ許容→仮説を並列化',
    '説明可能性>厳密性 を暫定優先',
    'センサー重み w=0.35',
    '自己修正ループ: on',
    '分布が広い→表現を圧縮',
  ];
  function pushLine(text, withCursor=false){
    const div=document.createElement('div'); div.className='line'+(withCursor?' cursor':''); div.textContent=text; streamEl.appendChild(div);
    // 古い行を削除
    const maxLines = parseInt(maxLinesEl.value,10); while(streamEl.children.length>maxLines){ streamEl.removeChild(streamEl.firstChild); }
    streamEl.scrollTo({ top: streamEl.scrollHeight, behavior:'smooth' });
  }
  function* typewriterChunks(str){ let i=0, step= (Math.random()<0.5?2:1); while(i<str.length){ yield str.slice(i, i+=step); } }
  async function typeLine(line){
    const it = typewriterChunks(line); let acc='';
    const stepFn=()=>{ const n=it.next(); if(n.done){ const last=streamEl.lastElementChild; if (last) last.classList.remove('cursor'); return; } acc+=n.value; const last=streamEl.lastElementChild; if(!last||!last.classList.contains('cursor')){ pushLine(acc,true);} else { last.textContent=acc; } streamEl.scrollTop=streamEl.scrollHeight; setTimeout(stepFn, parseInt(typingEl.value,10)); };
    stepFn();
  }
  async function startStream(){
    if(running) return; running=true; pushLine('--- THOUGHT STREAM ONLINE ---');
    const prompt = document.getElementById('prompt').value.trim();
    const loop = ()=>{
      if(!running) return;
      const base = seedPhrases[Math.floor(Math.random()*seedPhrases.length)];
      const sens = sensorSummary();
      const line = [new Date().toLocaleTimeString(), base, sens, (prompt?`hint:${prompt}`:'')].filter(Boolean).join('  //  ');
      typeLine(line);
      const linesPerMin = parseInt(rateEl.value,10); const interval = Math.max(60000/linesPerMin, 400); // 下限400ms
      loopTimer=setTimeout(loop, interval + Math.random()*0.4*interval);
    };
    loop();
  }
  function stopStream(){ running=false; clearTimeout(loopTimer); const last=streamEl.lastElementChild; if(last) last.classList.remove('cursor'); pushLine('--- PAUSED ---'); }

  btnToggle.addEventListener('click', ()=>{ if(!running){ btnToggle.textContent='⏸ PAUSE'; startStream(); } else { btnToggle.textContent='▶︎ START'; stopStream(); } });
  btnClear.addEventListener('click', ()=>{ streamEl.innerHTML=''; });

  // ====== 物体検出 (COCO-SSD) ======
  let model=null, detTimer=null;
  const TYPICAL_HEIGHT_M = { person:1.7, bottle:0.25, cup:0.1, chair:0.9, tv:0.6, laptop:0.3, book:0.22, cell_phone:0.15, mouse:0.04, keyboard:0.45, remote:0.15, backpack:0.45, handbag:0.30, suitcase:0.55, bicycle:1.05, car:1.45, bus:3.0, train:3.6, cat:0.26, dog:0.5, 'traffic light':0.6 };
  function focalPx(width, fovDeg){ const fov=fovDeg*Math.PI/180; return (0.5*width)/Math.tan(fov/2); }
  function estimateDistanceM(box, klass){ const pxH=box[3]; const W=overlay.width; const f=focalPx(W, parseInt(fovEl.value,10)); const Hm=TYPICAL_HEIGHT_M[klass]||0.3; if(pxH<=1) return null; return (Hm*f)/pxH; }
  function hsvFromRgb(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b); let h,s,v=max; const d=max-min; s=max===0?0:d/max; if(max===min) h=0; else{ switch(max){ case r: h=(g-b)/d+(g<b?6:0); break; case g: h=(b-r)/d+2; break; case b: h=(r-g)/d+4; break; } h/=6; } return {h:h*360,s,v}; }
  function isRedGreenFromCrop(imgData){ // 粗い信号色推定
    const data=imgData.data; let rc=0,gc=0; for(let i=0;i<data.length;i+=4){ const h=hsvFromRgb(data[i],data[i+1],data[i+2]); if(h.v<0.2||h.s<0.35) continue; if(h.h<25||h.h>335) rc++; else if(h.h>75&&h.h<170) gc++; }
    if(rc+gc<50) return null; return rc>gc? 'red':'green'; }
  function drawDetections(preds){
    octx.clearRect(0,0,overlay.width, overlay.height); octx.save(); octx.scale(-1,1); octx.translate(-overlay.width,0);
    preds.forEach(p=>{ const [x,y,w,h]=p.bbox; const d=estimateDistanceM([x,y,w,h], p.class); let extra='';
      if(p.class==='traffic light'){ try{ const crop=octx.getImageData(x,y,w,h); const col=isRedGreenFromCrop(crop); if(col){ extra=` ${col.toUpperCase()}`; if(a11yOnEl.checked) announceTraffic(col,d); } }catch(e){} }
      octx.strokeStyle='rgba(57,255,20,0.85)'; octx.lineWidth=2; octx.strokeRect(x,y,w,h);
      const tag=`${p.class} ${(p.score*100|0)}%${d?` ~${d.toFixed(1)}m`:''}${extra}`;
      octx.fillStyle='rgba(0,0,0,0.6)'; octx.fillRect(x, y-18, octx.measureText(tag).width+10, 18);
      octx.fillStyle='#39ff14'; octx.font='12px ui-monospace'; octx.fillText(tag, x+4, y-5);
    });
    octx.restore();
    // 黄線ガイドは別ループで描画を重ねる
  }

  // ====== 黄線（歩行ガイドライン）検出 ======
  let yellowTimer=null; const proc=document.createElement('canvas'), pctx=proc.getContext('2d');
  function detectYellowPath(){
    const W=overlay.width, H=overlay.height; if(W*H===0) return;
    proc.width=W; proc.height=H; pctx.drawImage(video,0,0,W,H);
    const roiH = Math.floor(H*0.5); // 下半分
    const img = pctx.getImageData(0, H-roiH, W, roiH); const data=img.data;
    // 黄色マスク（HSVで閾値）
    const mask = new Uint8Array(W*roiH); let sumX=0, count=0; const rowSamples=[];
    for(let y=0;y<roiH;y+=3){ // 3pxステップで軽量化
      let rowSum=0, rowCnt=0;
      for(let x=0;x<W;x+=2){ const i=((y*W)+x)*4; const h=hsvFromRgb(data[i],data[i+1],data[i+2]); if(h.v>0.35 && h.s>0.35 && h.h>20 && h.h<65){ mask[y*W+x]=1; sumX+=x; count++; rowSum+=x; rowCnt++; } }
      if(rowCnt>8) rowSamples.push({y, cx: rowSum/rowCnt});
    }
    // ガイド可視化
    octx.save(); octx.strokeStyle='rgba(255,255,0,0.9)'; octx.lineWidth=3; octx.setLineDash([8,6]);
    octx.beginPath(); let started=false; rowSamples.forEach(r=>{ const yy=H-roiH+r.y; const xx=W - r.cx; // ミラー補正
      if(!isFinite(xx)) return; if(!started){ octx.moveTo(xx,yy); started=true; } else { octx.lineTo(xx,yy);} }); octx.stroke();
    // 進行方向ガイド矢印
    if(rowSamples.length>4){ const head=rowSamples[ Math.max(0,rowSamples.length-8) ]; const tail=rowSamples[rowSamples.length-1];
      const hx=W - head.cx, hy=H-roiH+head.y; const tx=W - tail.cx, ty=H-roiH+tail.y; const ang=Math.atan2(ty-hy, tx-hx);
      drawArrow(tx,ty,ang);
      guideTurn(ang);
    }
    octx.restore();
    yellowTimer=setTimeout(detectYellowPath, 120); // 約8fps
  }
  function drawArrow(x,y,ang){ const L=36; octx.save(); octx.translate(x,y); octx.rotate(ang); octx.fillStyle='rgba(255,255,0,0.95)'; octx.beginPath(); octx.moveTo(0,0); octx.lineTo(-L,10); octx.lineTo(-L, -10); octx.closePath(); octx.fill(); octx.restore(); }
  function guideTurn(ang){ // -pi..pi, 右向き=0
    if(!a11yOnEl.checked) return; const deg=ang*180/Math.PI; let msg='まっすぐ'; if(deg<-10) msg='右へ'; else if(deg>10) msg='左へ'; speakThrottled(msg); beepFeedback(msg);
  }

  // ====== アクセシビリティ（音声・ビープ・振動） ======
  const a11yOnEl = document.getElementById('a11yOn');
  const langEl = document.getElementById('lang');
  const verbosityEl = document.getElementById('verbosity');
  const dangerEl = document.getElementById('dangerM');
  const cooldownEl = document.getElementById('cooldown');
  const beepOnEl = document.getElementById('beepOn');
  const vibeOnEl = document.getElementById('vibeOn');

  const synth = window.speechSynthesis;
  let lastSpeakAt=0;
  function speak(text){ if(!a11yOnEl.checked) return; const u=new SpeechSynthesisUtterance(text); u.lang= langEl.value==='ja' ? 'ja-JP' : 'en-US'; u.rate=1; synth.cancel(); synth.speak(u); }
  function speakThrottled(text){ const now=performance.now(); const cd=parseInt(cooldownEl.value,10)*1000; if(now-lastSpeakAt>cd){ lastSpeakAt=now; speak(text); if(vibeOnEl.checked && navigator.vibrate) navigator.vibrate(120); } }
  function beepFeedback(msg){ if(!beepOnEl.checked) return; try{ const ctx=new (window.AudioContext||window.webkitAudioContext)(); const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; const f = msg==='まっすぐ'? 600 : msg==='左へ'? 450 : 800; o.frequency.value=f; o.connect(g); g.connect(ctx.destination); g.gain.setValueAtTime(0.0001, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.08, ctx.currentTime+0.02); o.start(); o.stop(ctx.currentTime+0.12); }catch(e){} }
  function announceTraffic(color, dist){ let t=''; if(langEl.value==='ja'){ t = color==='red' ? '信号は赤です。止まってください。' : '信号は青です。渡れます。'; if(dist) t += ` およそ${dist.toFixed(1)}メートル前。`; } else { t = color==='red' ? 'Traffic light is RED. Stop.' : 'Traffic light is GREEN. Go.'; if(dist) t += ` About ${dist.toFixed(1)} meters ahead.`; } speakThrottled(t); }

  // ====== 起動ゲート ====== ======
  document.getElementById('gateStart').addEventListener('click', async ()=>{
    document.getElementById('gate').style.display='none';
    await startCamera();
    setupSensors();
    showToast('📦 物体検出モデル読込中…');
    try{ model = await cocoSsd.load({ base: 'lite_mobilenet_v2' }); showToast('✅ 物体検出モデル準備完了'); }
    catch(e){ console.warn(e); showToast('⚠ 物体検出モデルの読み込みに失敗（オフライン？）'); detectOnEl.checked=false; }
    detectionLoop();
    detectYellowPath();
  });
    setupSensors();
    // モデルのロード（必要なときだけ）
    showToast('📦 物体検出モデル読込中…');
    try{ model = await cocoSsd.load({ base: 'lite_mobilenet_v2' }); showToast('✅ 物体検出モデル準備完了'); }
    catch(e){ console.warn(e); showToast('⚠ 物体検出モデルの読み込みに失敗（オフライン？）'); detectOnEl.checked=false; }
    detectionLoop();
  });

  // 設定変更で検出ループ再スケジュール
  detectOnEl.addEventListener('change', ()=>{ clearTimeout(detTimer); detectionLoop(); });
  detIntEl.addEventListener('input', ()=>{ clearTimeout(detTimer); detectionLoop(); });
  fovEl.addEventListener('input', ()=>{ /* 次フレームで距離再計算 */ });

  // iOS 縦横変更対策
  window.addEventListener('orientationchange', ()=>{ if(video && video.srcObject) video.play().catch(()=>{}); setTimeout(resizeOverlay, 300); showToast('↻ 画面回転'); }); setTimeout(resizeOverlay, 300); });
</script>
</body>
</html>
