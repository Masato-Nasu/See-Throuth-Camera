<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum=1, user-scalable=no" />
<title>è¦–è¦šæ”¯æ´ARï¼šé»„ãƒ–ãƒ­ãƒƒã‚¯/æ¨ªæ–­æ­©é“/ä¿¡å·/æ‰‰/ãƒãƒ¼ãƒ«ï¼ˆæ”¹ï¼‰</title>
<meta name="description" content="é»„è‰²ã„ç‚¹å­—ãƒ–ãƒ­ãƒƒã‚¯ã®ãªãã‚Šã‚¬ã‚¤ãƒ‰ã€æ¨ªæ–­æ­©é“ã€ä¿¡å·ã®ç¾åœ¨è‰²ã€æ‰‰ãƒ»ãƒãƒ¼ãƒ«ãªã©å‰æ–¹éšœå®³ã‚’æ¤œå‡ºã—ã€ã²ã‚‰ãŒãªã§èª­ã¿ä¸Šã’ã¾ã™ã€‚">
<link rel="icon" href="data:," />
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.19.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
<style>
  :root{ --green:#39ff14; --text:#e8ffe8; --warn:#ff3b3b; --guide:#ffd400 }
  html,body{ margin:0; height:100%; background:#000; color:var(--text); font-family:ui-monospace,Menlo,Consolas,monospace; overflow:hidden }
  #wrap{ position:fixed; inset:0 }
  video{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover }
  canvas{ position:absolute; inset:0; pointer-events:none }
  #controls{
    position:fixed; left:0; right:0; bottom:0; display:flex; flex-wrap:wrap; gap:10px;
    padding:8px calc(10px + env(safe-area-inset-right)) calc(8px + env(safe-area-inset-bottom)) calc(10px + env(safe-area-inset-left));
    background:rgba(0,0,0,.15); border-top:1px solid rgba(57,255,20,.25); overflow-x:auto; -webkit-overflow-scrolling:touch; z-index:5
  }
  .label{ color:var(--green); font-size:12px; margin:0 4px }
  .range, select, .btn{ border:1px solid rgba(57,255,20,.45); background:rgba(0,0,0,.25); color:var(--text); border-radius:10px; padding:6px 10px; white-space:nowrap }
  .btn{ cursor:pointer }
  #gate{ position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.9); color:var(--text); z-index:10; text-align:center; gap:14px; padding:20px }
  #toast{ position:fixed; left:50%; transform:translateX(-50%); top:10px; padding:8px 12px; border:1px solid rgba(57,255,20,.5); border-radius:10px; background:rgba(0,0,0,.55); color:var(--green); display:none; z-index:20 }
</style>
</head>
<body>
  <div id="toast"></div>
  <div id="wrap">
    <video id="v" autoplay playsinline muted></video>
    <canvas id="ov"></canvas>
    <!-- å‡¦ç†ç”¨ãƒŸãƒ‹ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆãƒ“ãƒ‡ã‚ªã‹ã‚‰ã®åˆ‡ã‚Šå‡ºã—å…ƒï¼‰ -->
    <canvas id="proc" width="288" height="162" style="display:none"></canvas>
  </div>
  <div id="controls">
    <button class="btn" id="startBtn">â–¶ï¸ é–‹å§‹</button>
    <span class="label">FOVÂ°</span><input class="range" id="fov" type="range" min="50" max="95" value="70" />
    <span class="label">èª­ã¿ä¸Šã’</span>
    <select id="announceMode">
      <option value="important">é‡è¦ã®ã¿ï¼ˆäººãƒ»è»Šãƒ»è‡ªè»¢è»Šãƒ»ãƒã‚¹ï¼‰</option>
      <option value="people_vehicles">äººï¼‹ä¹—ã‚Šç‰©</option>
      <option value="all">ã™ã¹ã¦</option>
    </select>
    <span class="label">æœ€å¤§ä»¶æ•°</span><input class="range" id="topK" type="range" min="1" max="3" value="2" />
  </div>
  <div id="gate">
    <div>
      <h2 style="color:#39ff14;margin:0 0 6px">ã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒå¿…è¦ã§ã™</h2>
      <p style="margin:0 0 12px">HTTPSã§é–‹ã„ã¦ãã ã•ã„ã€‚é–‹å§‹ã§èƒŒé¢ã‚«ãƒ¡ãƒ©ï¼‹HUDãŒèµ·å‹•ã—ã¾ã™ã€‚</p>
      <button class="btn" id="gateStart">é–‹å§‹ / START</button>
    </div>
  </div>

<script>
(async()=>{
  // ===== DOM
  const v = document.getElementById('v');
  const ov = document.getElementById('ov'); const ctx = ov.getContext('2d');
  const proc = document.getElementById('proc'); const pctx = proc.getContext('2d', { willReadFrequently:true });
  const toast=(m)=>{ const t=document.getElementById('toast'); t.textContent=m; t.style.display='block'; clearTimeout(toast._t); toast._t=setTimeout(()=>t.style.display='none', 2000); };

  // ===== Speechï¼ˆã²ã‚‰ãŒãªå›ºå®šï¼‰
  const synth=window.speechSynthesis; const lastMap=new Map();
  function speakJaKana(t){ if(synth.speaking) return; const u=new SpeechSynthesisUtterance(t); u.lang='ja-JP'; u.rate=1; synth.speak(u); }
  function say(key, text, cd=1600){ const now=performance.now(), last=lastMap.get(key)||0; if(now-last>cd){ lastMap.set(key, now); speakJaKana(text); } }

  // ç‰©ä½“å â†’ ã²ã‚‰ãŒãªï¼ˆè¨“èª­ã¿å¯„ã›ï¼‰
  const JA_KANA = {
    person:'ã²ã¨', bicycle:'ã˜ã¦ã‚“ã—ã‚ƒ', car:'ãã‚‹ã¾', motorcycle:'ãƒã‚¤ã‚¯', bus:'ã°ã™', truck:'ãƒˆãƒ©ãƒƒã‚¯', train:'ã§ã‚“ã—ã‚ƒ',
    dog:'ã„ã¬', cat:'ã­ã“', bird:'ã¨ã‚Š',
    'traffic light':'ã—ã‚“ã”ã†', bench:'ãƒ™ãƒ³ãƒ', chair:'ã„ã™', 'potted plant':'ã‹ã‚“ã‚ˆã†ã—ã‚‡ãã¶ã¤',
    'stop sign':'ã„ã¡ã˜ã¦ã„ã— ã²ã‚‡ã†ã—ã', 'parking meter':'ãƒ‘ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¼ã‚¿ãƒ¼',
    bottle:'ãƒœãƒˆãƒ«', cup:'ã‚«ãƒƒãƒ—', laptop:'ãƒãƒ¼ãƒˆãƒ‘ã‚½ã‚³ãƒ³', tv:'ãƒ†ãƒ¬ãƒ“', 'cell phone':'ã‚¹ãƒãƒ›'
  };
  const toKana = (cls)=> JA_KANA[cls] || cls;

  // ===== Camera/Model
  let model=null;
  function resize(){ const w=v.videoWidth||innerWidth, h=v.videoHeight||innerHeight; ov.width=w; ov.height=h; }
  async function startCamera(){
    if(!window.isSecureContext && location.hostname!=='localhost' && location.hostname!=='127.0.0.1'){ toast('âš  HTTPSãŒå¿…è¦ã§ã™'); throw new Error('Insecure'); }
    const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:'environment'}},audio:false});
    v.srcObject=stream; await new Promise(r=>v.onloadedmetadata=r); await v.play(); resize(); addEventListener('resize',resize); toast('ğŸ“· ã‚«ãƒ¡ãƒ©èµ·å‹•');
  }
  async function loadModel(){ model=await cocoSsd.load({base:'lite_mobilenet_v2'}); }

  // ===== Angles & distance
  function angleToClock(ang){ const deg=ang*180/Math.PI; const off=Math.round(deg/30); let h=(12+off)%12; if(h===0) h=12; return h+'ã˜ ã»ã†ã“ã†'; }
  const TYPICAL_H={ person:1.7, bicycle:1.05, car:1.45, bus:3.0, truck:2.5, motorcycle:1.2, chair:0.9, bench:0.7, 'traffic light':0.7 };
  function focalPx(w,fovDeg){ const f=fovDeg*Math.PI/180; return (0.5*w)/Math.tan(f/2); }
  function estimateDistPx(bbox, cls){
    const h=bbox[3]; const H=TYPICAL_H[cls]||0.6; if(h<=1) return null;
    const W=(v.videoWidth||ov.width); const F=focalPx(W, parseInt(document.getElementById('fov').value,10));
    return (H*F)/h;
  }

  // ===== Color helpers
  function hsv(r,g,b){ r/=255; g/=255; b/=255; const M=Math.max(r,g,b), m=Math.min(r,g,b), d=M-m; let h=0; if(d){ switch(M){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;} h*=60; } const s=M?d/M:0; return {h,s,v:M}; }
  function rgb2lab(r,g,b){ r/=255; g/=255; b/=255; r=r>0.04045?Math.pow((r+0.055)/1.055,2.4):r/12.92; g=g>0.04045?Math.pow((g+0.055)/1.055,2.4):g/12.92; b=b>0.04045?Math.pow((b+0.055)/1.055,2.4):b/12.92;
    const x=(r*0.4124+g*0.3576+b*0.1805)/0.95047, y=(r*0.2126+g*0.7152+b*0.0722), z=(r*0.0193+g*0.1192+b*0.9505)/1.08883;
    const f=t=>t>0.008856?Math.cbrt(t):(7.787*t)+16/116; const fx=f(x), fy=f(y), fz=f(z); return {L:116*fy-16, a:500*(fx-fy), b:200*(fy-fz)}; }

  // === ãƒ“ãƒ‡ã‚ªãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ä»»æ„é ˜åŸŸã‚’åˆ‡ã‚Šå‡ºã™ï¼ˆâ€»ä¿¡å·è‰²ã®æ ¹æœ¬ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆï¼‰
  function getVideoCrop(x,y,w,h){
    // ã¾ãšå‡¦ç†ã‚­ãƒ£ãƒ³ãƒã‚¹ã¸ãƒ“ãƒ‡ã‚ªå…¨ä½“ã‚’ç¸®å°ã‚³ãƒ”ãƒ¼
    pctx.drawImage(v,0,0,proc.width,proc.height);
    const sx = proc.width / ov.width, sy = proc.height / ov.height;
    const ix = Math.max(0, Math.floor(x*sx)), iy = Math.max(0, Math.floor(y*sy));
    const iw = Math.max(1, Math.floor(w*sx)), ih = Math.max(1, Math.floor(h*sy));
    try{ return pctx.getImageData(ix,iy,iw,ih); }catch(e){ return null; }
  }

  // === ä¿¡å·ã®è‰²åˆ¤å®šï¼ˆé’ç·‘ï¼æ—¥æœ¬ã®â€œé’â€ã‚’åºƒãæ‹¾ã†ï¼‰
  function tlColorFromCrop(img){
    if(!img) return null;
    const d=img.data; let rc=0,gc=0,yc=0;
    for(let i=0;i<d.length;i+=4){
      const H=hsv(d[i],d[i+1],d[i+2]);
      // æš—æ‰€ãƒã‚¤ã‚ºé™¤å»
      if(H.v<0.18 || H.s<0.22) continue;
      // èµ¤
      if(H.h<20 || H.h>340) rc++;
      // é’ã€œç·‘ï¼ˆæ—¥æœ¬ã®â€œé’â€ã‚’å«ã‚€: 75ã€œ190ã¾ã§æ‹¡å¼µã—ã‚·ã‚¢ãƒ³åŸŸã‚‚ï¼‰
      else if(H.h>=75 && H.h<=190) gc++;
      // é»„
      else if(H.h>=20 && H.h<75) yc++;
    }
    const sum=rc+gc+yc; if(sum<40) return null;
    if(gc>rc && gc>yc) return 'ã‚ãŠ';      // é’ï¼ˆé’ç·‘å«ã‚€ï¼‰
    if(rc>gc && rc>yc) return 'ã‚ã‹';      // èµ¤
    return 'ãã„ã‚';                        // é»„
  }

  // ===== é»„è‰²ã„ç‚¹å­—ãƒ–ãƒ­ãƒƒã‚¯
  function detectYellowGuide(){
    const W=ov.width, H=ov.height, pw=proc.width, ph=proc.height;
    // ä¸‹åŠåˆ†ã‚’å¼·èª¿ã—ã¦å–å¾—
    pctx.drawImage(v,0,0,pw,ph);
    const img=pctx.getImageData(0,0,pw,ph), d=img.data;

    const yStart=Math.floor(ph*0.35);
    const pts=[];
    for(let y=yStart;y<ph;y++){
      for(let x=0;x<pw;x++){
        const i=(y*pw+x)*4, r=d[i], g=d[i+1], b=d[i+2];
        const H=hsv(r,g,b), L=rgb2lab(r,g,b);
        // å¤œé–“/å½±ã«å¼·ã„ä¸‰ç³»çµ±ã—ãã„å€¤ï¼ˆå°‘ã—ç·©å’Œï¼‰
        const condHSV = (H.h>16 && H.h<75 && H.s>0.24 && H.v>0.24);
        const condLab = (L.b>10 && L.a>-8);
        const condRG  = (((r+g)>>1) - b > 20) && (r>g*0.75) && (g>b*1.10);
        if(condHSV || condLab || condRG) pts.push([x,y]);
      }
    }
    // ç”»ç´ ãŒå°‘ãªã„ã¨ãã¯ã‚¹ã‚­ãƒƒãƒ—
    if(pts.length<120) return null;

    // RANSACç›´ç·šï¼ˆx = a*y + bï¼‰
    let best={a:0,b:0,cnt:0};
    for(let t=0;t<100;t++){
      const p1=pts[(Math.random()*pts.length)|0], p2=pts[(Math.random()*pts.length)|0];
      const dy=p2[1]-p1[1]; if(Math.abs(dy)<1) continue;
      const a=(p2[0]-p1[0])/dy, b=p1[0]-a*p1[1];
      let c=0; for(let k=0;k<pts.length;k+=5){ const x=a*pts[k][1]+b; if(Math.abs(x-pts[k][0])<4) c++; }
      if(c>best.cnt) best={a,b,cnt:c};
    }
    if(best.cnt<70) return null;

    const sx=W/pw, sy=H/ph;
    const y1=Math.floor(H*0.55), y2=H-8;
    const x1=(best.a*(y1/sy)+best.b)*sx, x2=(best.a*(y2/sy)+best.b)*sx;
    const cx=(x1+x2)/2;
    const ang=((cx - W/2)/(W/2))*(Math.PI/2);
    return {x1,y1,x2,y2,ang};
  }

  // ===== æ¨ªæ–­æ­©é“ï¼ˆãƒã‚¤ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆç¸æ¤œå‡ºãƒ»é–¾å€¤å¾®èª¿æ•´ï¼‰
  function detectCrosswalk(){
    const W=ov.width,H=ov.height,pw=proc.width,ph=proc.height;
    pctx.drawImage(v,0,0,pw,ph);
    const img=pctx.getImageData(0,0,pw,ph), d=img.data;
    const y0=Math.floor(ph*0.55);
    const cols=new Array(pw).fill(0);
    for(let y=y0;y<ph;y++){
      for(let x=0;x<pw;x++){
        const i=(y*pw+x)*4;
        const Y=0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2];
        if(Y>195) cols[x]++;
      }
    }
    let bands=0, run=0;
    for(let x=0;x<pw;x++){ if(cols[x]>(ph-y0)*0.42) run++; else { if(run>3){ bands++; } run=0; } }
    if(bands>=3){ return {x:W*0.05,y:H*0.64,w:W*0.90,h:H*0.30}; }
    return null;
  }

  // ===== ãƒ‰ã‚¢ï¼†ãƒãƒ¼ãƒ«ï¼ˆãƒãƒ¼ãƒ«ã‚’æ‹¾ã„ã‚„ã™ãã€ãƒ‰ã‚¢æ ã¨åˆ†é›¢ï¼‰
  function detectDoorAndPole(){
    const W=ov.width,H=ov.height,pw=proc.width,ph=proc.height;
    pctx.drawImage(v,0,0,pw,ph);
    const img=pctx.getImageData(0,0,pw,ph), d=img.data;
    const gray=new Uint8ClampedArray(pw*ph);
    for(let i=0,j=0;i<d.length;i+=4,j++) gray[j]=(d[i]*0.2126+d[i+1]*0.7152+d[i+2]*0.0722)|0;

    // Sobel X / Y & è¿‘ä¼¼å‹¾é…
    const gx=[-1,0,1,-2,0,2,-1,0,1], gy=[-1,-2,-1,0,0,0,1,2,1];
    const ex=new Int16Array(pw*ph), mag=new Uint16Array(pw*ph);
    for(let y=1;y<ph-1;y++){
      for(let x=1;x<pw-1;x++){
        let sx=0,sy=0,t=0;
        for(let yy=-1;yy<=1;yy++) for(let xx=-1;xx<=1;xx++){
          const v=gray[(y+yy)*pw+(x+xx)];
          sx += v*gx[t]; sy += v*gy[t]; t++;
        }
        ex[y*pw+x]=sx; mag[y*pw+x]=Math.min(1023,Math.abs(sx)+Math.abs(sy));
      }
    }

    // æ¢ç´¢é ˜åŸŸï¼ˆå‰æ–¹ä¸­å¿ƒï¼‰
    const rx0=Math.floor(pw*0.18), rx1=Math.floor(pw*0.82);
    const ry0=Math.floor(ph*0.22), ry1=Math.floor(ph*0.92);

    // === ãƒ‰ã‚¢ï¼ˆå·¦å³ãƒ•ãƒ¬ãƒ¼ãƒ ã®å¼·ã„ç¸¦ã‚¨ãƒƒã‚¸ï¼‹å†…å´ã‚¨ãƒƒã‚¸ã®å°‘ãªã•ï¼‰
    let bestDoor=null, scoreD=0;
    for(let y=ry0;y<ry1;y+=3){
      for(let x=rx0;x<rx1;x+=3){
        const w=48, h=Math.floor(w*2.5);
        if(x+w>=pw-1 || y+h>=ph-1) continue;
        if(y+h < ph*0.50) continue; // ä½ã‚ã«ã‚ã‚‹çŸ©å½¢ã‚’å„ªå…ˆ
        let eL=0,eR=0,inE=0;
        for(let yy=0;yy<h;yy+=2){ eL+=Math.abs(ex[(y+yy)*pw+x]); eR+=Math.abs(ex[(y+yy)*pw+(x+w)]); }
        for(let yy=4;yy<h-4;yy+=5){ for(let xx=6;xx<w-6;xx+=6){ inE += mag[(y+yy)*pw+(x+xx)]>190?1:0; } }
        const ar=h/w; if(ar<1.8||ar>3.8) continue;
        const wr=w/pw; if(wr<0.10||wr>0.42) continue;
        const sc=(eL+eR)-inE*5;
        if(sc>scoreD){ scoreD=sc; bestDoor={x,y,w,h}; }
      }
    }

    // === ãƒãƒ¼ãƒ«ï¼ˆåˆ—æ–¹å‘ã®ç™½ç³»é€£ç¶šï¼‹å·¦å³ã‚¨ãƒƒã‚¸ï¼‹å†…éƒ¨å¤‰å‹•ã§å††æŸ±ã£ã½ã•ï¼‰
    let bestPole=null, scoreP=0;
    for(let x=rx0;x<rx1;x+=2){
      let run=0,maxRun=0,y0=0,y1=0;
      for(let y=ry0;y<ry1;y++){
        const Y=gray[y*pw+x]; if(Y>170){ if(run===0) y0=y; run++; } else { if(run>maxRun){ maxRun=run; y1=y-1; } run=0; }
      }
      const h=maxRun; if(h<ph*0.38) continue; // ã‹ãªã‚Šé«˜ã„ç¸¦è¦ç´ ã®ã¿
      const w=4; if(x+w>=pw) continue;
      let eL=0,eR=0,varIn=0,cnt=0;
      for(let y=y0;y<y1;y+=2){ eL+=Math.abs(ex[y*pw+x]); eR+=Math.abs(ex[y*pw+(x+w)]); if(x+2<pw){ varIn+=Math.abs(gray[y*pw+(x+1)]-gray[y*pw+(x+2)]); cnt++; } }
      const mv=cnt?varIn/cnt:0;
      // å¹…ã®ä¸Šé™ï¼ˆç´°ã„æŸ±ã«é™å®šï¼‰ï¼†å†…éƒ¨å¤‰å‹•ã®ã—ãã„å€¤ã‚’ç·©ã‚
      if(w/pw>0.035) continue;
      if(mv<1.0) continue;
      const sc=(eL+eR)/(1+Math.abs(mv-5)); // ã ã„ãŸã„5ä»˜è¿‘ã‚’å¥½ã‚€
      if(sc>scoreP){ scoreP=sc; bestPole={x, y:y0, w, h}; }
    }

    // ãƒ‰ã‚¢ç¸¦æ ã¨ãƒãƒ¼ãƒ«ã®æ··åŒã‚’æŠ‘åˆ¶
    if(bestDoor && bestPole){
      const cx=bestPole.x+bestPole.w/2;
      const inside=(cx>bestDoor.x-6 && cx<bestDoor.x+bestDoor.w+6);
      const overlap=!(bestPole.y+bestPole.h<bestDoor.y || bestPole.y>bestDoor.y+bestDoor.h);
      if(inside && overlap) bestPole=null;
    }

    const sx=ov.width/pw, sy=ov.height/ph;
    return {
      door: bestDoor?{x:bestDoor.x*sx,y:bestDoor.y*sy,w:bestDoor.w*sx,h:bestDoor.h*sy}:null,
      pole: bestPole?{x:bestPole.x*sx,y:bestPole.y*sy,w:bestPole.w*sx,h:bestPole.h*sy}:null
    };
  }

  // ===== Main draw
  function draw(preds){
    ctx.clearRect(0,0,ov.width,ov.height);

    // å‰æ–¹ROI
    const ROI = {x: ov.width*0.33, y: ov.height*0.44, w: ov.width*0.34, h: ov.height*0.44};
    ctx.strokeStyle='rgba(255,255,255,.18)'; ctx.lineWidth=2; ctx.strokeRect(ROI.x,ROI.y,ROI.w,ROI.h);

    // é»„ãƒ–ãƒ­ãƒƒã‚¯
    const guide=detectYellowGuide();
    if(guide){
      ctx.lineWidth=8; ctx.strokeStyle='rgba(255,212,0,0.95)';
      ctx.beginPath(); ctx.moveTo(guide.x1,guide.y1); ctx.lineTo(guide.x2,guide.y2); ctx.stroke();
      const tag=`ãŠã†ã ã‚“ãƒ–ãƒ­ãƒƒã‚¯ï¼š${angleToClock(((guide.x1+guide.x2)/2-ov.width/2)/(ov.width/2)*(Math.PI/2))}`;
      ctx.font='700 24px ui-monospace,Menlo,Consolas,monospace';
      const tw=ctx.measureText(tag).width+16; ctx.fillStyle='rgba(0,0,0,.65)'; ctx.fillRect(8,8,tw,30);
      ctx.fillStyle='var(--guide)'; ctx.fillText(tag,16,30);
      say('yellow', `${angleToClock( ((guide.x1+guide.x2)/2-ov.width/2)/(ov.width/2)*(Math.PI/2) )}ã€ãã„ã‚ã„ ã¦ã‚“ã˜ãƒ–ãƒ­ãƒƒã‚¯ã€‚`, 2200);
    }

    // æ¨ªæ–­æ­©é“
    const zebra=detectCrosswalk();
    if(zebra){ ctx.strokeStyle='rgba(255,255,255,.9)'; ctx.lineWidth=3; ctx.strokeRect(zebra.x,zebra.y,zebra.w,zebra.h); say('zebra','ã¾ãˆã« ãŠã†ã ã‚“ã»ã©ã†ã€‚',2500); }

    // COCO-SSD
    const Wpx=(v.videoWidth||ov.width);
    const K=parseInt(document.getElementById('topK').value,10)||1;
    const mode=document.getElementById('announceMode').value;
    const allow=(cls)=>{ if(mode==='all') return true; const pv=['person','car','bicycle','bus','motorcycle','truck']; const imp=['person','car','bicycle','bus']; return mode==='people_vehicles'? pv.includes(cls):imp.includes(cls); };

    const minScore=0.52;
    const items = preds.filter(p=>p.score>=minScore).map(p=>{
      const [x,y,w,h]=p.bbox; const cx=x+w/2; const ang=((cx-Wpx/2)/(Wpx/2))*(Math.PI/2);
      const dist=estimateDistPx(p.bbox,p.class); return {...p,ang,dist};
    }).sort((a,b)=>{ const da=a.dist??1e9, db=b.dist??1e9; if(da!==db) return da-db; return b.score-a.score; });

    let said=0; let nearestObstacle=Infinity;
    items.forEach(p=>{
      const [x,y,w,h]=p.bbox; const dir=angleToClock(p.ang); const dt=(p.dist? Math.max(0.5,p.dist):null);
      const label=`${dir} ${toKana(p.class)}${dt? ' '+dt.toFixed(1)+'m':''}`;

      // æ 
      const isObs=['person','car','bicycle','bus','motorcycle','truck','bench','chair','potted plant','stop sign','traffic light'].includes(p.class);
      ctx.strokeStyle=isObs?'rgba(255,59,59,.9)':'rgba(57,255,20,.95)'; ctx.lineWidth=3; ctx.strokeRect(x,y,w,h);
      // ãƒ©ãƒ™ãƒ«ï¼ˆæ—¥æœ¬èªå¤§ãã‚ï¼‰
      ctx.font='600 22px ui-monospace,Menlo,Consolas,monospace';
      const tw=ctx.measureText(label).width+16; const pad=28;
      let lx=Math.min(Math.max(x,4), ov.width-tw-4); let ly=(y>=32)?y-4:y+h+pad+4; if(ly+(-pad)<0) ly=y+h+pad+4;
      ctx.fillStyle='rgba(0,0,0,.7)'; ctx.fillRect(lx,ly-pad,tw,pad); ctx.fillStyle=isObs?'#ff7d7d':'#39ff14'; ctx.fillText(label,lx+8,ly-7);

      // â˜… ä¿¡å·ã®è‰²ï¼ˆãƒ“ãƒ‡ã‚ªãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰æ­£ã—ãåˆ‡ã‚Šå‡ºã—ï¼‰
      if(p.class==='traffic light'){
        const crop=getVideoCrop(x,y,w,h);
        const c=tlColorFromCrop(crop);
        if(c){ say('tl', `ã—ã‚“ã”ã† ã¯ ã„ã¾ã€${c}ã€‚`, 2200); }
      }

      // ROIï¼†è·é›¢ï¼ˆ5mï¼‰ã§éšœå®³ã¨ã—ã¦é›†è¨ˆ
      const cx=x+w/2, cy=y+h/2; const inROI = (cx>ROI.x && cx<ROI.x+ROI.w && cy>ROI.y && cy<ROI.y+ROI.h);
      if(isObs && dt && dt<5 && (inROI || dt<1.5)){ nearestObstacle=Math.min(nearestObstacle, dt); }

      // è¿‘ã„é †ã®èª­ã¿ä¸Šã’
      if(said<K && allow(p.class)){
        const t = `${dir}ã€${dt? dt.toFixed(1)+'ãƒ¡ãƒ¼ãƒˆãƒ«ã€':''}${toKana(p.class)}ã€‚`;
        say(`obj_${p.class}_${dir}`, t, 1400); said++;
      }
    });

    // æ‰‰ãƒ»ãƒãƒ¼ãƒ«ï¼ˆç‹¬è‡ªæ¤œå‡ºï¼‰
    const {door, pole}=detectDoorAndPole();
    if(door){
      ctx.strokeStyle='rgba(255,200,0,.95)'; ctx.lineWidth=3; ctx.strokeRect(door.x,door.y,door.w,door.h);
      const ang=((door.x+door.w/2-ov.width/2)/(ov.width/2))*(Math.PI/2);
      say('door', `${angleToClock(ang)}ã€ã¨ã³ã‚‰ã€‚`,2000);
      if(door.y+door.h/2>ROI.y && door.y<ROI.y+ROI.h) nearestObstacle=Math.min(nearestObstacle,2.8);
    }
    if(pole){
      ctx.strokeStyle='rgba(255,140,0,.95)'; ctx.lineWidth=3; ctx.strokeRect(pole.x,pole.y,pole.w,pole.h);
      const ang=((pole.x+pole.w/2-ov.width/2)/(ov.width/2))*(Math.PI/2);
      say('pole', `${angleToClock(ang)}ã€ãƒãƒ¼ãƒ«ã€‚ã¡ã‚…ã†ã„ã€‚`,2000);
      if(pole.y+pole.h/2>ROI.y && pole.y<ROI.y+ROI.h) nearestObstacle=Math.min(nearestObstacle,2.2);
    }

    // 5mä»¥å†…ã«å‰æ–¹éšœå®³ãªã—
    if(nearestObstacle===Infinity){ say('clear5', 'ã¾ãˆã€5ãƒ¡ãƒ¼ãƒˆãƒ« ãªã„ã« ã—ã‚‡ã†ãŒã„ ãªã—ã€‚', 3800); }
  }

  async function loop(){
    try{ const preds=await model.detect(v); draw(preds); }catch(e){ console.warn(e); }
    setTimeout(loop, 520);
  }

  // ==== UI
  document.getElementById('fov').addEventListener('input',()=>{ toast('FOV '+fov.value+'Â°'); say('fov','ãã‚‡ã‚Š ã»ã›ã„ ã‚’ ã“ã†ã—ã‚“ã€‚',1200); model && model.detect(v).then(draw).catch(()=>{}); });

  // ==== Boot
  async function startAll(){
    document.getElementById('gate').style.display='none';
    await startCamera(); toast('ğŸ“¦ ãƒ¢ãƒ‡ãƒ« ã‚ˆã¿ã“ã¿â€¦'); await loadModel(); toast('âœ… ã˜ã‚…ã‚“ã³ ã‹ã‚“ã‚Šã‚‡ã†'); loop();
  }
  document.getElementById('gateStart').onclick=()=>{ startAll().catch(console.error); };
  document.getElementById('startBtn').onclick=()=>{ startAll().catch(console.error); };
})();
</script>
</body>
</html>
