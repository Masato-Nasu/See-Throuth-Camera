<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>è¦–è¦šæ”¯æ´ARï¼šç·‘HUD + ç‰©ä½“æ¤œå‡º + é»„ç·šã‚¬ã‚¤ãƒ‰ + ä¿¡å·è‰²</title>
  <meta name="description" content="è¦–è¦šæ”¯æ´ãƒ¢ãƒ¼ãƒ‰ï¼ˆéŸ³å£°æ¡ˆå†…ãƒ»ãƒ“ãƒ¼ãƒ—ãƒ»æŒ¯å‹•ï¼‰ã¤ãå®Ÿé¨“çš„ARã‚¢ãƒ—ãƒªã€‚é»„ç·šã‚¬ã‚¤ãƒ‰/ä¿¡å·è‰²æ¨å®šå¯¾å¿œã€‚" />
  <!-- TF.js & COCO-SSD (ç‰©ä½“æ¤œå‡º) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.19.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
  <style>
    :root{ --bg:#000; --grid:rgba(0,255,128,.12); --green:#39ff14; --text:#d7ffd7; }
    html,body{ margin:0;height:100%;background:var(--bg);color:var(--text);font-family:ui-monospace,Menlo,Consolas,monospace;overflow:hidden; }
    #camWrap{ position:fixed; inset:0; overflow:hidden; }
    #video{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; filter:saturate(1.1) contrast(1.05) brightness(1.05);  }
    #overlay{ position:absolute; inset:0; pointer-events:none; }
    #hud{ position:fixed; inset:0; pointer-events:none; }
    .panel{ position:absolute; left:50%; transform:translateX(-50%); bottom:6vh; width:min(1000px,92vw); height:56vh; background:linear-gradient(180deg,rgba(0,0,0,.15),rgba(0,0,0,.35)); border:1px solid rgba(57,255,20,.35); border-radius:16px; box-shadow:0 0 24px rgba(57,255,20,.12), inset 0 0 40px rgba(57,255,20,.06); backdrop-filter:blur(6px) saturate(1.1); -webkit-backdrop-filter:blur(6px) saturate(1.1); overflow:hidden; }
    .panel::before{ content:""; position:absolute; inset:0; background:repeating-linear-gradient(to bottom, rgba(0,255,128,.05), rgba(0,255,128,.05) 2px, transparent 2px, transparent 6px); mix-blend-mode:screen; animation:scan 5s linear infinite; }
    @keyframes scan{ from{transform:translateY(-10%)} to{transform:translateY(10%)} }
    .panel::after{ content:""; position:absolute; inset:0; background:linear-gradient(var(--grid) 1px, transparent 1px), linear-gradient(90deg, var(--grid) 1px, transparent 1px); background-size:32px 32px, 32px 32px; mask-image:linear-gradient(to top, transparent, rgba(0,0,0,.6) 30%, rgba(0,0,0,.9)); }
    .title{ position:absolute; inset:0 0 auto 0; height:42px; background:linear-gradient(90deg, rgba(57,255,20,.2), rgba(57,255,20,0), rgba(57,255,20,.2)); border-bottom:1px solid rgba(57,255,20,.35); display:flex; align-items:center; padding:0 16px; font-weight:600; letter-spacing:.06em; color:var(--green); text-shadow:0 0 8px rgba(57,255,20,.8), 0 0 18px rgba(57,255,20,.4); }
    #stream{ position:absolute; top:50px; bottom:98px; left:0; right:0; padding:14px 16px 24px; overflow:hidden; font-size:clamp(12px,1.9vw,16px); line-height:1.6; }
    .line{ opacity:.95; margin:2px 0; white-space:pre-wrap; word-break:break-word; text-shadow:0 0 10px rgba(57,255,20,.55), 0 0 28px rgba(57,255,20,.35); }
    .cursor::after{ content:"â–Œ"; animation:blink 1s steps(1,start) infinite; color:var(--green) }
    @keyframes blink{ 50%{opacity:0} }
    #controls{ position:absolute; inset:auto 0 0 0; height:98px; display:flex; flex-wrap:wrap; gap:8px; align-items:center; padding:8px 10px; background:linear-gradient(0deg, rgba(0,0,0,.55), rgba(0,0,0,.15)); border-top:1px solid rgba(57,255,20,.25); pointer-events:auto; }
    .btn{ border:1px solid rgba(57,255,20,.55); background:rgba(0,0,0,.25); color:var(--green); padding:8px 12px; border-radius:10px; font-weight:600; letter-spacing:.04em; cursor:pointer; box-shadow:0 0 12px rgba(57,255,20,.25) inset; }
    .input,.range,select{ border:1px solid rgba(57,255,20,.35); background:rgba(0,0,0,.25); color:var(--text); border-radius:8px; padding:6px 10px; }
    .label{ color:var(--green); font-size:12px; margin:0 6px 0 4px; opacity:.9; }
    #gate{ position:fixed; inset:0; display:grid; place-items:center; background:radial-gradient(1200px 600px at center, rgba(0,0,0,.6), rgba(0,0,0,.92)); color:var(--text); z-index:10; text-align:center; padding:24px; }
    #gate .start{ font-size:18px; padding:12px 20px; border-radius:14px; cursor:pointer; border:1px solid rgba(57,255,20,.6); background:rgba(0,0,0,.35); color:var(--green); text-shadow:0 0 10px rgba(57,255,20,.9); }
    @media (max-width:640px){ .panel{ height:60vh } #controls{ height:108px } #stream{ bottom:108px } }
  </style>
</head>
<body>
  <div id="toast" style="position:fixed;left:50%;transform:translateX(-50%);top:10px;padding:8px 12px;border:1px solid rgba(57,255,20,.5);border-radius:10px;background:rgba(0,0,0,.55);color:#39ff14;font:12px ui-monospace;z-index:20;display:none"></div>

  <div id="camWrap">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="hud">
    <div class="panel" id="panel">
      <div class="title">A11y AR â€” OBJECTS / RANGE / TRAFFIC / YELLOW or GAP GUIDE</div>
      <!-- æ€è€ƒã‚¹ãƒˆãƒªãƒ¼ãƒ å‰Šé™¤: ãƒŠãƒ“å°‚ç”¨UIã«ç°¡ç´ åŒ– -->
      <div id="controls">
        <button class="btn" id="btnToggle">â–¶ï¸ START</button>
        <button class="btn" id="btnClear">CLEAR</button>
        <span class="label">Detect</span>
        <input id="detectOn" type="checkbox" checked aria-label="ç‰©ä½“æ¤œå‡ºã‚ªãƒ³" />
        <span class="label">FOVÂ°</span>
        <input class="range" id="fov" type="range" min="45" max="85" value="60" />
        <span class="label">Intvl(ms)</span>
        <input class="range" id="detInt" type="range" min="250" max="1800" value="700" />
        <span class="label">A11y</span>
        <input id="a11yOn" type="checkbox" aria-label="è¦–è¦šæ”¯æ´ãƒ¢ãƒ¼ãƒ‰" checked />
        <span class="label">Lang</span>
        <select id="lang" aria-label="è¨€èª"><option value="ja">æ—¥æœ¬èª</option><option value="en">English</option></select>
        <span class="label">Cooldown s</span>
        <input class="range" id="cooldown" type="range" min="1" max="8" value="2" />
        <span class="label">Beep</span>
        <input id="beepOn" type="checkbox" checked aria-label="ãƒ“ãƒ¼ãƒ—éŸ³ã‚ªãƒ³" />
        <span class="label">Vibe</span>
        <input id="vibeOn" type="checkbox" checked aria-label="ãƒã‚¤ãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚ªãƒ³" />
        <span class="label">Guide</span>
        <select id="guideMode" aria-label="ã‚¬ã‚¤ãƒ‰ãƒ¢ãƒ¼ãƒ‰">
          <option value="yellow_first">é»„ç·šå„ªå…ˆ</option>
          <option value="gap_only">ã‚®ãƒ£ãƒƒãƒ—èª˜å°</option>
        </select>
      </div>
    </div>
  </div>

  <div id="gate">
    <div>
      <h2 style="margin:0 0 10px 0;color:#39ff14;text-shadow:0 0 16px rgba(57,255,20,.9)">ã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒå¿…è¦ã§ã™</h2>
      <p style="margin:0 0 16px 0">ã€Œé–‹å§‹ã€ã‚’æŠ¼ã™ã¨ã€èƒŒé¢ã‚«ãƒ¡ãƒ©æ˜ åƒã«ãƒã‚ªãƒ³ã‚°ãƒªãƒ¼ãƒ³HUDã€é»„ç·šã‚¬ã‚¤ãƒ‰ã€ä¿¡å·æ¨å®šã‚’é‡ã­ã¾ã™ã€‚</p>
      <button class="start" id="gateStart">é–‹å§‹ / START</button>
      <small>â€» HTTPSå¿…é ˆã€‚ä¿¡å·/è·é›¢ã¯å˜çœ¼ã®æ¦‚ç®—ã§ã™ã€‚</small>
    </div>
  </div>

<script>
  // ===== util =====
  function showToast(msg){ const t=document.getElementById('toast'); t.textContent=msg; t.style.display='block'; clearTimeout(showToast._timer); showToast._timer=setTimeout(()=>{ t.style.display='none'; }, 2500); }

  // ===== camera & canvas =====
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const octx = overlay.getContext('2d');

  async function startCamera(){
    if (!window.isSecureContext) { showToast('âš  HTTPSãŒå¿…è¦ã§ã™'); throw new Error('Insecure context'); }
    video.setAttribute('playsinline','');
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ ideal:'environment' } }, audio:false });
      video.srcObject = stream;
      await new Promise(res=> video.onloadedmetadata = res);
      await video.play();
      resizeOverlay();
      window.addEventListener('resize', resizeOverlay);
      showToast('ğŸ“· ã‚«ãƒ¡ãƒ©èµ·å‹•');
    }catch(err){ console.error(err); showToast('âŒ ã‚«ãƒ¡ãƒ©å¤±æ•—: '+err.message); alert('ã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã§ã—ãŸ:
'+err.name+': '+err.message); throw err; }
  }
  function resizeOverlay(){ overlay.width = video.clientWidth || window.innerWidth; overlay.height = video.clientHeight || window.innerHeight; }

  // ===== sensors =====
  const sensors = { motion:null, orientation:null, geo:null };
  function setupSensors(){
    if (window.DeviceMotionEvent){ window.addEventListener('devicemotion', e=>{ sensors.motion={ ax:e.accelerationIncludingGravity?.x??0, ay:e.accelerationIncludingGravity?.y??0, az:e.accelerationIncludingGravity?.z??0 }; }, {passive:true}); }
    if (window.DeviceOrientationEvent){ window.addEventListener('deviceorientation', e=>{ sensors.orientation={ alpha:e.alpha, beta:e.beta, gamma:e.gamma }; }, {passive:true}); }
    if (navigator.geolocation){ navigator.geolocation.getCurrentPosition(pos=>{ sensors.geo={ lat:pos.coords.latitude.toFixed(5), lon:pos.coords.longitude.toFixed(5) }; }, ()=>{}, { maximumAge:60000, timeout:3000 }); }
  }
  function sensorSummary(){ const p=[]; if (sensors.geo) p.push(`GPS ${sensors.geo.lat},${sensors.geo.lon}`); if (sensors.motion) p.push(`acc x:${sensors.motion.ax?.toFixed(1)} y:${sensors.motion.ay?.toFixed(1)} z:${sensors.motion.az?.toFixed(1)}`); if (sensors.orientation) p.push(`ori Î±:${sensors.orientation.alpha?.toFixed(0)} Î²:${sensors.orientation.beta?.toFixed(0)} Î³:${sensors.orientation.gamma?.toFixed(0)}`); return p.join(' | '); }

  // ===== object detection & traffic light color ===== & traffic light color =====
  let model=null, detTimer=null;
  const detectOnEl = document.getElementById('detectOn');
  const fovEl = document.getElementById('fov');
  const detIntEl = document.getElementById('detInt');
  const TYPICAL_HEIGHT_M = { person:1.7, bottle:0.25, cup:0.1, chair:0.9, tv:0.6, laptop:0.3, book:0.22, cell_phone:0.15, mouse:0.04, keyboard:0.45, remote:0.15, backpack:0.45, handbag:0.30, suitcase:0.55, bicycle:1.05, car:1.45, bus:3.0, train:3.6, cat:0.26, dog:0.5, 'traffic light':0.6 };
  function focalPx(width, fovDeg){ const fov=fovDeg*Math.PI/180; return (0.5*width)/Math.tan(fov/2); }
  function estimateDistanceM(box, klass){ const pxH=box[3]; const W=overlay.width; const f=focalPx(W, parseInt(fovEl.value,10)); const Hm=TYPICAL_HEIGHT_M[klass]||0.3; if(pxH<=1) return null; return (Hm*f)/pxH; }
  function hsvFromRgb(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b); let h=0,s=0,v=max; const d=max-min; s=max===0?0:d/max; if(max!==min){ switch(max){ case r: h=(g-b)/d+(g<b?6:0); break; case g: h=(b-r)/d+2; break; case b: h=(r-g)/d+4; break; } h/=6; } return {h:h*360,s,v}; }
  function isRedGreenFromCrop(imgData){ const data=imgData.data; let rc=0,gc=0; for(let i=0;i<data.length;i+=4){ const h=hsvFromRgb(data[i],data[i+1],data[i+2]); if(h.v<0.2||h.s<0.35) continue; if(h.h<25||h.h>335) rc++; else if(h.h>75&&h.h<170) gc++; } if(rc+gc<50) return null; return rc>gc? 'red':'green'; }
  function drawDetections(preds){
    octx.clearRect(0,0,overlay.width, overlay.height);
    // æç”»ã®åŸºæº–ã¯ãƒŸãƒ©ãƒ¼ç„¡ã—
    preds.forEach(p=>{
      const [x,y,w,h]=p.bbox; const cx=x+w/2; const cy=y+h/2;
      const d=estimateDistanceM([x,y,w,h], p.class);
      // æ–¹å‘æ¨å®šï¼ˆæ°´å¹³FOVã‹ã‚‰è§’åº¦ï¼‰
      const W=overlay.width; const fov=parseInt(fovEl.value,10)*Math.PI/180; const dx=(cx - W/2); const ang = (dx/(W/2))*(fov/2); // å·¦è² ,å³æ­£ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
      // ãƒ©ãƒ™ãƒ«
      let extra='';
      if(p.class==='traffic light'){
        try{ const crop=octx.getImageData(x,y,w,h); const col=isRedGreenFromCrop(crop); if(col){ extra=` ${col.toUpperCase()}`; if(a11yOnEl.checked) announceTraffic(col,d); } }catch(e){}
      }
      // æ 
      octx.strokeStyle='rgba(57,255,20,.85)'; octx.lineWidth=2; octx.strokeRect(x,y,w,h);
      const dirTxt = angleToText(ang);
      const tag = `${p.class} ${(p.score*100|0)}%${d?` ~${d.toFixed(1)}m`:''} ${dirTxt}${extra}`;
      octx.fillStyle='rgba(0,0,0,.6)'; octx.font='12px ui-monospace'; const tw=octx.measureText(tag).width+10; octx.fillRect(x, y-18, tw, 18);
      octx.fillStyle='#39ff14'; octx.fillText(tag, x+4, y-5);
      // ã‚¢ãƒŠã‚¦ãƒ³ã‚¹ï¼ˆæŠ‘åˆ¶ä»˜ãï¼‰
      maybeAnnounceObject(p.class, d, ang);
    });
  }{ octx.clearRect(0,0,overlay.width, overlay.height); octx.save(); octx.scale(-1,1); octx.translate(-overlay.width,0); preds.forEach(p=>{ const [x,y,w,h]=p.bbox; const d=estimateDistanceM([x,y,w,h], p.class); let extra=''; if(p.class==='traffic light'){ try{ const crop=octx.getImageData(x,y,w,h); const col=isRedGreenFromCrop(crop); if(col){ extra=` ${col.toUpperCase()}`; if(a11yOnEl.checked) announceTraffic(col,d); } }catch(e){} } octx.strokeStyle='rgba(57,255,20,.85)'; octx.lineWidth=2; octx.strokeRect(x,y,w,h); const tag=`${p.class} ${(p.score*100|0)}%${d?` ~${d.toFixed(1)}m`:''}${extra}`; octx.fillStyle='rgba(0,0,0,.6)'; const tw = (octx.measureText(tag).width||120)+10; octx.fillRect(x, y-18, tw, 18); octx.fillStyle='#39ff14'; octx.font='12px ui-monospace'; octx.fillText(tag, x+4, y-5); }); octx.restore(); }
  async function detectionLoop(){ if(!detectOnEl.checked || !model){ octx.clearRect(0,0,overlay.width, overlay.height); return; } try{ const preds = await model.detect(video); drawDetections(preds); }catch(e){ console.warn(e); } detTimer=setTimeout(detectionLoop, parseInt(detIntEl.value,10)); }

  // ===== yellow line (guide) + gap-based fallback =====
  let yellowTimer=null; const proc=document.createElement('canvas'), pctx=proc.getContext('2d');
  function detectYellowPath(){
    const W=overlay.width, H=overlay.height; if(W*H===0){ yellowTimer=setTimeout(detectYellowPath,200); return; }
    proc.width=W; proc.height=H; pctx.drawImage(video,0,0,W,H);
    const roiH=Math.floor(H*0.5); const img=pctx.getImageData(0,H-roiH,W,roiH); const data=img.data;
    const rowSamples=[]; let yellowCount=0;
    for(let y=0;y<roiH;y+=3){ let rowSum=0,rowCnt=0; for(let x=0;x<W;x+=2){ const i=((y*W)+x)*4; const {h,s,v}=hsvFromRgb(data[i],data[i+1],data[i+2]); if(v>0.35 && s>0.35 && h>20 && h<65){ rowSum+=x; rowCnt++; yellowCount++; } } if(rowCnt>8) rowSamples.push({y, cx: rowSum/rowCnt}); }
    octx.save();
    const useYellow = (guideModeEl.value==='yellow_first' && yellowCount>150);
    if(useYellow){
      // é»„ç·šã‚¬ã‚¤ãƒ‰æç”»
      octx.strokeStyle='rgba(255,255,0,.9)'; octx.lineWidth=3; octx.setLineDash([8,6]); octx.beginPath(); let started=false; rowSamples.forEach(r=>{ const yy=H-roiH+r.y; const xx=r.cx; if(!isFinite(xx)) return; if(!started){ octx.moveTo(xx,yy); started=true; } else { octx.lineTo(xx,yy);} }); octx.stroke();
      if(rowSamples.length>4){ const head=rowSamples[Math.max(0,rowSamples.length-8)]; const tail=rowSamples[rowSamples.length-1]; const ang=Math.atan2((H-roiH+tail.y)-(H-roiH+head.y), tail.cx-head.cx); drawArrow(tail.cx, H-roiH+tail.y, ang); guideTurn(ang); }
    } else {
      // Fallback: ç‰©ä½“æ¤œå‡ºã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‹ã‚‰ä¸‹åŠåˆ†ã®éšœå®³ãƒãƒƒãƒ—ã‚’ä½œã‚Šã€æœ€ã‚‚åºƒã„ã‚®ãƒ£ãƒƒãƒ—ã‚’é€šè·¯ã¨è¦‹ãªã™
      const columns = 64; const colW = W/columns; const occ = new Array(columns).fill(0);
      (lastDetections||[]).forEach(p=>{ const [x,y,w,h]=p.bbox; const by=y+h; if(by < H*0.5) return; const start=Math.max(0, Math.floor(x/colW)); const end=Math.min(columns-1, Math.floor((x+w)/colW)); for(let c=start;c<=end;c++) occ[c]=1; });
      let bestLen=0,bestStart=0; let cur=0,curStart=0; for(let c=0;c<columns;c++){ if(occ[c]===0){ if(cur===0) curStart=c; cur++; if(cur>bestLen){ bestLen=cur; bestStart=curStart; } } else { cur=0; } }
      const gapCx = (bestStart + bestLen/2)*colW; const gapW = bestLen*colW;
      // å¯è¦–åŒ–
      octx.fillStyle='rgba(0,255,128,0.15)'; octx.fillRect(bestStart*colW, H-roiH, gapW, roiH);
      octx.strokeStyle='rgba(0,255,128,0.9)'; octx.lineWidth=3; octx.setLineDash([10,6]); octx.beginPath(); octx.moveTo(gapCx, H-roiH); octx.lineTo(gapCx, H); octx.stroke();
      const ang = Math.atan2( (H - (H-roiH)), (gapCx - W/2) ); drawArrow(gapCx, H-10, ang);
      guideTurn(ang);
    }
    octx.restore();
    yellowTimer=setTimeout(detectYellowPath, 120);
  } }
  function drawArrow(x,y,ang){ const L=36; octx.save(); octx.translate(x,y); octx.rotate(ang); octx.fillStyle='rgba(255,255,0,.95)'; octx.beginPath(); octx.moveTo(0,0); octx.lineTo(-L,10); octx.lineTo(-L,-10); octx.closePath(); octx.fill(); octx.restore(); }

  // ===== accessibility: speech / beep / vibration =====
  const a11yOnEl = document.getElementById('a11yOn');
  const langEl = document.getElementById('lang');
  const cooldownEl = document.getElementById('cooldown');
  const beepOnEl = document.getElementById('beepOn');
  const vibeOnEl = document.getElementById('vibeOn');
  const guideModeEl = document.getElementById('guideMode');
  const synth = window.speechSynthesis;
  let lastSpeakAt=0; const spokeMap = new Map();
  function speak(text){ if(!a11yOnEl.checked) return; const u=new SpeechSynthesisUtterance(text); u.lang=(langEl.value==='ja')?'ja-JP':'en-US'; u.rate=1; try{synth.cancel();}catch(_){} synth.speak(u); }
  function speakThrottled(key, text){ const now=performance.now(); const cd=parseInt(cooldownEl.value,10)*1000; const last=spokeMap.get(key)||0; if(now-last>cd){ spokeMap.set(key,now); speak(text); if(vibeOnEl.checked && navigator.vibrate) navigator.vibrate(120); } }
  function beep(f){ try{ const ctx=new (window.AudioContext||window.webkitAudioContext)(); const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; o.frequency.value=f; o.connect(g); g.connect(ctx.destination); g.gain.setValueAtTime(0.0001, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.08, ctx.currentTime+0.02); o.start(); o.stop(ctx.currentTime+0.12); }catch(e){} }
  function beepFeedback(dir){ if(!beepOnEl.checked) return; const f = dir==='straight'?600 : dir==='left'? 450 : 800; beep(f); }
  function angleToText(ang){ const deg=ang*180/Math.PI; if(deg<-15) return (langEl.value==='ja')?'å·¦':'left'; if(deg>15) return (langEl.value==='ja')?'å³':'right'; return (langEl.value==='ja')?'å‰æ–¹':'ahead'; }
  function guideTurn(ang){ if(!a11yOnEl.checked) return; const deg=ang*180/Math.PI; let dir='straight'; if(deg<-10) dir='left'; else if(deg>10) dir='right'; const msg = (langEl.value==='ja') ? (dir==='straight'?'ã¾ã£ã™ã': dir==='left'?'å·¦ã¸':'å³ã¸') : (dir==='straight'?'straight': dir==='left'?'left':'right'); speakThrottled('guide', msg); beepFeedback(dir); }
  function announceTraffic(color, dist){ const key='traffic_'+color; let t=''; if(langEl.value==='ja'){ t = color==='red' ? 'ä¿¡å·ã¯èµ¤ã§ã™ã€‚æ­¢ã¾ã£ã¦ãã ã•ã„ã€‚' : 'ä¿¡å·ã¯é’ã§ã™ã€‚æ¸¡ã‚Œã¾ã™ã€‚'; if(dist) t += ` ãŠã‚ˆã${dist.toFixed(1)}ãƒ¡ãƒ¼ãƒˆãƒ«å‰ã€‚`; } else { t = color==='red' ? 'Traffic light is RED. Stop.' : 'Traffic light is GREEN. Go.'; if(dist) t += ` About ${dist.toFixed(1)} meters ahead.`; } speakThrottled(key, t); }
  function maybeAnnounceObject(cls, dist, ang){ if(!a11yOnEl.checked) return; if(!dist) return; const dirTxt = angleToText(ang); // å„ªå…ˆã‚¯ãƒ©ã‚¹ã®ã¿é »åº¦é«˜ã‚
    const pri = (cls==='person'||cls==='car'||cls==='bicycle'||cls==='bus') ? 1 : 2;
    const key = `obj_${pri}_${cls}_${dirTxt}`;
    const dtxt = (langEl.value==='ja') ? `${Math.max(0.5, dist).toFixed(1)}ãƒ¡ãƒ¼ãƒˆãƒ«` : `${Math.max(0.5, dist).toFixed(1)} meters`;
    let text = '';
    if(langEl.value==='ja') text = `${dirTxt}ã€${dtxt}ã€${cls}`; else text = `${cls}, ${dtxt}, ${dirTxt}`;
    // å„ªå…ˆ1ã¯ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³åŠåˆ†
    const saved = cooldownEl.value; if(pri===1){ cooldownEl.value = Math.max(1, cooldownEl.value/2); }
    speakThrottled(key, text);
    cooldownEl.value = saved;
  }(ang){ if(!a11yOnEl.checked) return; const deg=ang*180/Math.PI; let msgJa='ã¾ã£ã™ã', msgEn='straight'; if(deg<-10){ msgJa='å³ã¸'; msgEn='right'; } else if(deg>10){ msgJa='å·¦ã¸'; msgEn='left'; } const msg = (langEl.value==='ja')? msgJa : msgEn; speakThrottled((langEl.value==='ja')? msgJa : msgEn); beepFeedback(msg); }
  function announceTraffic(color, dist){ let t=''; if(langEl.value==='ja'){ t = color==='red' ? 'ä¿¡å·ã¯èµ¤ã§ã™ã€‚æ­¢ã¾ã£ã¦ãã ã•ã„ã€‚' : 'ä¿¡å·ã¯é’ã§ã™ã€‚æ¸¡ã‚Œã¾ã™ã€‚'; if(dist) t += ` ãŠã‚ˆã${dist.toFixed(1)}ãƒ¡ãƒ¼ãƒˆãƒ«å‰ã€‚`; } else { t = color==='red' ? 'Traffic light is RED. Stop.' : 'Traffic light is GREEN. Go.'; if(dist) t += ` About ${dist.toFixed(1)} meters ahead.`; } speakThrottled(t); }

  // ===== UI wiring =====
  const btnToggle=document.getElementById('btnToggle');
  const btnClear=document.getElementById('btnClear');
  const detectOn=document.getElementById('detectOn');
  btnToggle.addEventListener('click', ()=>{ if(!running){ btnToggle.textContent='â¸ PAUSE'; startStream(); } else { btnToggle.textContent='â–¶ï¸ START'; stopStream(); } });
  btnClear.addEventListener('click', ()=>{ streamEl.innerHTML=''; });
  detectOn.addEventListener('change', ()=>{ clearTimeout(detTimer); detectionLoop(); });
  detIntEl.addEventListener('input', ()=>{ clearTimeout(detTimer); detectionLoop(); });
  window.addEventListener('orientationchange', ()=>{ if(video && video.srcObject) video.play().catch(()=>{}); setTimeout(resizeOverlay, 300); showToast('â†» ç”»é¢å›è»¢'); });

  // ===== gate =====
  document.getElementById('gateStart').addEventListener('click', async ()=>{
    document.getElementById('gate').style.display='none';
    await startCamera();
    setupSensors();
    showToast('ğŸ“¦ ç‰©ä½“æ¤œå‡ºãƒ¢ãƒ‡ãƒ«èª­è¾¼ä¸­â€¦');
    try{ model = await cocoSsd.load({ base:'lite_mobilenet_v2' }); showToast('âœ… ç‰©ä½“æ¤œå‡ºãƒ¢ãƒ‡ãƒ«æº–å‚™å®Œäº†'); }
    catch(e){ console.warn(e); showToast('âš  ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—ï¼ˆã‚ªãƒ•ãƒ©ã‚¤ãƒ³ï¼Ÿï¼‰'); document.getElementById('detectOn').checked=false; }
    detectionLoop();
    detectYellowPath();
  });
</script>
</body>
</html>
