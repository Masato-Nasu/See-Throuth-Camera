<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>è¦–è¦šæ”¯æ´ARï¼šé»„ç·š/æ¨ªæ–­æ­©é“/ä¿¡å·/æ‰‰/ãƒãƒ¼ãƒ«ã‚¬ã‚¤ãƒ‰</title>
<meta name="description" content="é»„è‰²ã„ç‚¹å­—ãƒ–ãƒ­ãƒƒã‚¯ã®ãªãã‚Šã‚¬ã‚¤ãƒ‰ã€ç™½é»’ã®æ¨ªæ–­æ­©é“ã€ä¿¡å·ã®ç¾åœ¨è‰²ã€æ‰‰ãƒ»çª“ãƒ»ãƒãƒ¼ãƒ«ãªã©å‰æ–¹éšœå®³ã‚’æ¤œå‡ºã—ã¦æ—¥æœ¬èªã§æ¡ˆå†…ã—ã¾ã™ã€‚">
<!-- TensorFlow.js & COCO-SSD -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.19.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
<style>
  :root{ --green:#39ff14; --text:#e8ffe8; --warn:#ff3b3b; --guide:#ffd400; }
  html,body{ margin:0; height:100%; background:#000; color:var(--text); font-family:ui-monospace,Menlo,Consolas,monospace; overflow:hidden }
  #wrap{ position:fixed; inset:0; }
  video{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover }
  canvas{ position:absolute; inset:0; pointer-events:none }
  #controls{
    position:fixed; left:0; right:0; bottom:0; display:flex; flex-wrap:wrap; gap:10px;
    padding:8px calc(10px + env(safe-area-inset-right)) calc(8px + env(safe-area-inset-bottom)) calc(10px + env(safe-area-inset-left));
    background:rgba(0,0,0,0.15); border-top:1px solid rgba(57,255,20,.25); overflow-x:auto; -webkit-overflow-scrolling:touch; z-index:5
  }
  .label{ color:var(--green); font-size:12px; margin:0 4px }
  .range, select, .btn{ border:1px solid rgba(57,255,20,.45); background:rgba(0,0,0,.25); color:var(--text); border-radius:10px; padding:6px 10px; white-space:nowrap }
  .btn{ cursor:pointer }
  #gate{ position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.9); color:var(--text); z-index:10; text-align:center; gap:14px; padding:20px }
  #toast{ position:fixed; left:50%; transform:translateX(-50%); top:10px; padding:8px 12px; border:1px solid rgba(57,255,20,.5); border-radius:10px; background:rgba(0,0,0,.55); color:var(--green); display:none; z-index:20 }
</style>
<link rel="icon" href="data:," />
</head>
<body>
  <div id="toast"></div>
  <div id="wrap">
    <video id="v" autoplay playsinline muted></video>
    <canvas id="ov"></canvas>
    <canvas id="proc" width="192" height="108" style="display:none"></canvas>
  </div>
  <div id="controls">
    <button class="btn" id="startBtn">â–¶ï¸ é–‹å§‹</button>
    <span class="label">FOVÂ°</span><input class="range" id="fov" type="range" min="45" max="95" value="70" />
    <span class="label">èª­ã¿ä¸Šã’</span>
    <select id="announceMode">
      <option value="important">é‡è¦ã®ã¿ï¼ˆäººãƒ»è»Šãƒ»è‡ªè»¢è»Šãƒ»ãƒã‚¹ï¼‰</option>
      <option value="people_vehicles">äººï¼‹ä¹—ã‚Šç‰©</option>
      <option value="all">ã™ã¹ã¦</option>
    </select>
    <span class="label">æœ€å¤§ä»¶æ•°</span><input class="range" id="topK" type="range" min="1" max="3" value="1" />
  </div>
  <div id="gate">
    <div>
      <h2 style="color:#39ff14;margin:0 0 6px">ã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒå¿…è¦ã§ã™</h2>
      <p style="margin:0 0 12px">HTTPSã§é–‹ã„ã¦ãã ã•ã„ã€‚é–‹å§‹ã§èƒŒé¢ã‚«ãƒ¡ãƒ©ï¼‹HUDãŒèµ·å‹•ã—ã¾ã™ã€‚</p>
      <button class="btn" id="gateStart">é–‹å§‹ / START</button>
    </div>
  </div>

<script>
(async()=>{
  // ==== DOM / Canvas
  const v = document.getElementById('v');
  const ov = document.getElementById('ov');
  const ctx = ov.getContext('2d');
  const proc = document.getElementById('proc');
  const pctx = proc.getContext('2d');

  const toast=(m)=>{ const t=document.getElementById('toast'); t.textContent=m; t.style.display='block'; clearTimeout(toast._t); toast._t=setTimeout(()=>t.style.display='none', 2400); };

  let model=null, detTimer=null;

  // ==== Speech helpers
  const synth=window.speechSynthesis; const lastMap=new Map();
  function speak(t){ if(synth.speaking) return; const u=new SpeechSynthesisUtterance(t); u.lang='ja-JP'; u.rate=1; synth.speak(u); }
  function sayThrottle(key, text, cd=1600){ const now=performance.now(), last=lastMap.get(key)||0; if(now-last>cd){ lastMap.set(key, now); speak(text); } }

  // ==== Geometry / conversions
  function resize(){ const w=v.videoWidth||innerWidth; const h=v.videoHeight||innerHeight; ov.width=w; ov.height=h; }
  function angleToClock(ang){ const deg=ang*180/Math.PI; const off=Math.round(deg/30); let hour=(12+off)%12; if(hour===0) hour=12; return hour+'æ™‚æ–¹å‘'; }
  const TYPICAL_H={ person:1.7, bicycle:1.05, car:1.45, bus:3.0, truck:2.5, motorcycle:1.2, dog:0.5, cat:0.26, chair:0.9, bottle:0.25, cup:0.1, laptop:0.3, 'traffic light':0.6, bench:0.7 };
  function focalPx(w,fovDeg){ const f=fovDeg*Math.PI/180; return (0.5*w)/Math.tan(f/2); }
  function estimateDistPx(bbox, cls){ const h=bbox[3]; const H=TYPICAL_H[cls]||0.6; if(h<=1) return null; const W=(v.videoWidth||ov.width); const F=focalPx(W, parseInt(document.getElementById('fov').value,10)); return (H*F)/h; }

  // ==== Colors
  function hsvFromRgb(r,g,b){ r/=255; g/=255; b/=255; const M=Math.max(r,g,b), m=Math.min(r,g,b); let h=0,s=0,v=M, d=M-m; s=M===0?0:d/M; if(M!==m){ switch(M){ case r:h=(g-b)/d+(g<b?6:0);break; case g:h=(b-r)/d+2;break; case b:h=(r-g)/d+4; } h/=6; } return {h:h*360,s,v}; }
  function rgb2lab(r,g,b){ r/=255; g/=255; b/=255;
    r=r>0.04045?Math.pow((r+0.055)/1.055,2.4):r/12.92;
    g=g>0.04045?Math.pow((g+0.055)/1.055,2.4):g/12.92;
    b=b>0.04045?Math.pow((b+0.055)/1.055,2.4):b/12.92;
    const x=(r*0.4124+g*0.3576+b*0.1805)/0.95047;
    const y=(r*0.2126+g*0.7152+b*0.0722)/1.0;
    const z=(r*0.0193+g*0.1192+b*0.9505)/1.08883;
    const f=t=>t>0.008856?Math.cbrt(t):(7.787*t)+16/116;
    const fx=f(x), fy=f(y), fz=f(z);
    return {L:(116*fy)-16, a:500*(fx-fy), b:200*(fy-fz)};
  }

  // ==== Model & camera
  async function loadModelWithFallback(){
    try{ model=await cocoSsd.load({base:'lite_mobilenet_v2'}); return true; }
    catch(e1){
      try{ await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://unpkg.com/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js'; s.onload=res; s.onerror=rej; document.head.appendChild(s); });
           model=await cocoSsd.load({base:'lite_mobilenet_v2'}); return true; }
      catch(e2){ console.warn('[A11yAR] coco-ssd load failed', e1, e2); return false; }
    }
  }
  async function startCamera(){
    if(!window.isSecureContext && location.hostname!=='localhost' && location.hostname!=='127.0.0.1'){ toast('âš  HTTPSãŒå¿…è¦ã§ã™'); throw new Error('Insecure'); }
    const stream=await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ ideal:'environment' } }, audio:false });
    v.srcObject=stream; await new Promise(res=> v.onloadedmetadata=res); await v.play(); resize(); addEventListener('resize', resize); toast('ğŸ“· ã‚«ãƒ¡ãƒ©èµ·å‹•');
  }

  // ==== Japanese labels
  function toJa(cls){
    const map={
      person:'äºº', bicycle:'è‡ªè»¢è»Š', car:'è»Š', motorcycle:'ãƒã‚¤ã‚¯', airplane:'é£›è¡Œæ©Ÿ', bus:'ãƒã‚¹', train:'é›»è»Š', truck:'ãƒˆãƒ©ãƒƒã‚¯', boat:'ãƒœãƒ¼ãƒˆ',
      'traffic light':'ä¿¡å·', 'fire hydrant':'æ¶ˆç«æ “', 'stop sign':'ä¸€æ™‚åœæ­¢æ¨™è­˜', 'parking meter':'ãƒ‘ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¼ã‚¿ãƒ¼', bench:'ãƒ™ãƒ³ãƒ',
      bird:'é³¥', cat:'çŒ«', dog:'çŠ¬', horse:'é¦¬', sheep:'ç¾Š', cow:'ç‰›', elephant:'è±¡', bear:'ç†Š', zebra:'ã‚·ãƒã‚¦ãƒ', giraffe:'ã‚­ãƒªãƒ³',
      backpack:'ãƒªãƒ¥ãƒƒã‚¯', umbrella:'å‚˜', handbag:'ãƒãƒ³ãƒ‰ãƒãƒƒã‚°', tie:'ãƒã‚¯ã‚¿ã‚¤', suitcase:'ã‚¹ãƒ¼ãƒ„ã‚±ãƒ¼ã‚¹',
      frisbee:'ãƒ•ãƒªã‚¹ãƒ“ãƒ¼', skis:'ã‚¹ã‚­ãƒ¼æ¿', snowboard:'ã‚¹ãƒãƒ¼ãƒœãƒ¼ãƒ‰', 'sports ball':'ãƒœãƒ¼ãƒ«', kite:'å‡§', 'baseball bat':'ãƒãƒƒãƒˆ', 'baseball glove':'ã‚°ãƒ­ãƒ¼ãƒ–', skateboard:'ã‚¹ã‚±ãƒ¼ãƒˆãƒœãƒ¼ãƒ‰', surfboard:'ã‚µãƒ¼ãƒ•ãƒœãƒ¼ãƒ‰', 'tennis racket':'ãƒ†ãƒ‹ã‚¹ãƒ©ã‚±ãƒƒãƒˆ',
      bottle:'ãƒœãƒˆãƒ«', 'wine glass':'ãƒ¯ã‚¤ãƒ³ã‚°ãƒ©ã‚¹', cup:'ã‚«ãƒƒãƒ—', fork:'ãƒ•ã‚©ãƒ¼ã‚¯', knife:'ãƒŠã‚¤ãƒ•', spoon:'ãƒ—ãƒ¼ãƒ³', bowl:'ãƒœã‚¦ãƒ«',
      banana:'ãƒãƒŠãƒŠ', apple:'ã‚Šã‚“ã”', sandwich:'ã‚µãƒ³ãƒ‰ã‚¤ãƒƒãƒ', orange:'ã‚ªãƒ¬ãƒ³ã‚¸', broccoli:'ãƒ–ãƒ­ãƒƒã‚³ãƒªãƒ¼', carrot:'ã«ã‚“ã˜ã‚“', 'hot dog':'ãƒ›ãƒƒãƒˆãƒ‰ãƒƒã‚°', pizza:'ãƒ”ã‚¶', donut:'ãƒ‰ãƒ¼ãƒŠãƒ„', cake:'ã‚±ãƒ¼ã‚­',
      chair:'æ¤…å­', couch:'ã‚½ãƒ•ã‚¡', 'potted plant':'è¦³è‘‰æ¤ç‰©', bed:'ãƒ™ãƒƒãƒ‰', 'dining table':'ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°ãƒ†ãƒ¼ãƒ–ãƒ«', toilet:'ãƒˆã‚¤ãƒ¬',
      tv:'ãƒ†ãƒ¬ãƒ“', laptop:'ãƒãƒ¼ãƒˆPC', mouse:'ãƒã‚¦ã‚¹', remote:'ãƒªãƒ¢ã‚³ãƒ³', keyboard:'ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰', 'cell phone':'ã‚¹ãƒãƒ›',
      microwave:'é›»å­ãƒ¬ãƒ³ã‚¸', oven:'ã‚ªãƒ¼ãƒ–ãƒ³', toaster:'ãƒˆãƒ¼ã‚¹ã‚¿ãƒ¼', sink:'æµã—å°', refrigerator:'å†·è”µåº«',
      book:'æœ¬', clock:'æ™‚è¨ˆ', vase:'èŠ±ç“¶', scissors:'ã¯ã•ã¿', 'teddy bear':'ã¬ã„ãã‚‹ã¿', 'hair drier':'ãƒ‰ãƒ©ã‚¤ãƒ¤ãƒ¼', toothbrush:'æ­¯ãƒ–ãƒ©ã‚·'
    };
    return map[cls]||cls;
  }

  // ==== Yellow tactile paving (robust)
  function detectYellowGuide(){
    const W=ov.width, H=ov.height, pw=proc.width, ph=proc.height;
    pctx.drawImage(v,0,0,pw,ph);
    const img=pctx.getImageData(0,0,pw,ph); const d=img.data;

    const pts=[];
    const yStart=Math.floor(ph*0.40);
    for(let y=yStart;y<ph;y++){
      for(let x=0;x<pw;x++){
        const i=(y*pw+x)*4;
        const r=d[i], g=d[i+1], b=d[i+2];
        const {h,s,v}=hsvFromRgb(r,g,b); const lab=rgb2lab(r,g,b);
        if((h>20 && h<70 && s>0.35 && v>0.35) || (lab.b>20 && lab.a>0)) pts.push([x,y]);
      }
    }
    if(pts.length<200) return null;

    // RANSACé¢¨ç›´ç·šå½“ã¦ã¯ã‚ï¼ˆx = a*y + bï¼‰
    let best={a:0,b:0,count:0};
    for(let t=0;t<60;t++){
      const p1=pts[(Math.random()*pts.length)|0], p2=pts[(Math.random()*pts.length)|0];
      const dy=p2[1]-p1[1]; if(Math.abs(dy)<1) continue;
      const a=(p2[0]-p1[0])/dy, b=p1[0]-a*p1[1];
      let c=0; for(let k=0;k<pts.length;k+=8){ const x=a*pts[k][1]+b; if(Math.abs(x-pts[k][0])<2.5) c++; }
      if(c>best.count) best={a,b,count:c};
    }
    if(best.count<80) return null;

    const y1=Math.floor(H*0.55), y2=H-6;
    const sx=W/pw, sy=H/ph;
    const x1=(best.a*(y1/sy)+best.b)*sx;
    const x2=(best.a*(y2/sy)+best.b)*sx;
    const cx=(x1+x2)/2;
    const ang=((cx - W/2)/(W/2))*(Math.PI/2);
    return {x1,y1,x2,y2,ang};
  }

  // ==== Crosswalk (white-black stripes)
  function detectCrosswalk(){
    const W=ov.width,H=ov.height,pw=proc.width,ph=proc.height;
    pctx.drawImage(v,0,0,pw,ph);
    const img=pctx.getImageData(0,0,pw,ph); const d=img.data;
    const y0=Math.floor(ph*0.55);
    let cols=new Array(pw).fill(0);
    for(let y=y0;y<ph;y++){
      for(let x=0;x<pw;x++){
        const i=(y*pw+x)*4;
        const Y=0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2];
        if(Y>200) cols[x]++;
      }
    }
    let bands=0, run=0;
    for(let x=0;x<pw;x++){ if(cols[x]>(ph-y0)*0.45) run++; else { if(run>3){ bands++; } run=0; } }
    if(bands>=3){ return {x:W*0.05,y:H*0.65,w:W*0.90,h:H*0.30}; }
    return null;
  }

  // ==== Entrance (door) & pole detector (improved)
  function detectEntranceAndPole(){
    const W=ov.width, H=ov.height, pw=proc.width, ph=proc.height;
    pctx.drawImage(v,0,0,pw,ph);
    const img=pctx.getImageData(0,0,pw,ph); const d=img.data;

    const gray=new Uint8ClampedArray(pw*ph);
    for(let i=0,j=0;i<d.length;i+=4,j++) gray[j]=(d[i]*0.2126+d[i+1]*0.7152+d[i+2]*0.0722)|0;

    const gx=[-1,0,1,-2,0,2,-1,0,1], gy=[-1,-2,-1,0,0,0,1,2,1];
    const ex=new Int16Array(pw*ph), mag=new Uint16Array(pw*ph);
    for(let y=1;y<ph-1;y++){
      for(let x=1;x<pw-1;x++){
        let sx=0,sy=0,t=0;
        for(let yy=-1;yy<=1;yy++) for(let xx=-1;xx<=1;xx++){
          const v=gray[(y+yy)*pw+(x+xx)];
          sx += v * gx[t]; sy += v * gy[t]; t++;
        }
        ex[y*pw+x]=sx; mag[y*pw+x]=Math.min(1023, Math.abs(sx)+Math.abs(sy));
      }
    }

    // æ¢ç´¢é ˜åŸŸ
    const rx0=Math.floor(pw*0.22), rx1=Math.floor(pw*0.78);
    const ry0=Math.floor(ph*0.25), ry1=Math.floor(ph*0.90);

    // æ‰‰
    let bestDoor=null,bestScore=0;
    for(let y=ry0;y<ry1;y+=3){
      for(let x=rx0;x<rx1;x+=3){
        const w=48, h=Math.floor(w*2.6);
        if(x+w>=pw-1 || y+h>=ph-1) continue;
        if(y+h < ph*0.55) continue; // ä¸‹åŠåˆ†ã«ã‹ã‹ã‚‹
        let leftE=0,rightE=0,insideE=0;
        for(let yy=0;yy<h;yy+=2){ leftE+=Math.abs(ex[(y+yy)*pw+x]); rightE+=Math.abs(ex[(y+yy)*pw+(x+w)]); }
        for(let yy=4;yy<h-4;yy+=4){ for(let xx=6;xx<w-6;xx+=6){ insideE += mag[(y+yy)*pw+(x+xx)]>180 ? 1:0; } }
        const aspect=h/w; if(aspect<1.8 || aspect>3.8) continue;
        const widthRatio=w/pw; if(widthRatio<0.10 || widthRatio>0.40) continue;
        const score=(leftE+rightE) - insideE*6;
        if(score>bestScore){ bestScore=score; bestDoor={x,y,w,h,score}; }
      }
    }

    // ãƒãƒ¼ãƒ«ï¼ˆç´°ãã¦èƒŒãŒé«˜ã„ï¼‹ä¸¡ç«¯ã«ç¸¦ã‚¨ãƒƒã‚¸ï¼‹å†…å´è¼åº¦ã®å¤‰å‹•å°‘ãªã™ããªã„ï¼‰
    let bestPole=null,poleScore=0;
    for(let x=rx0;x<rx1;x+=2){
      let run=0,maxRun=0, y0=0,y1=0;
      for(let y=ry0;y<ry1;y++){
        const Y=gray[y*pw+x];
        if(Y>185){ if(run===0) y0=y; run++; }
        else{ if(run>maxRun){ maxRun=run; y1=y-1; } run=0; }
      }
      const h=maxRun; if(h<ph*0.45) continue;
      const w=4; if(x+w>=pw) continue;
      let edgeL=0,edgeR=0,varInside=0,cnt=0;
      for(let y=y0;y<y1;y+=2){
        edgeL+=Math.abs(ex[y*pw+x]); edgeR+=Math.abs(ex[y*pw+(x+w)]);
        if(x+2<pw){ const a=gray[y*pw+(x+1)], b=gray[y*pw+(x+2)]; varInside+=Math.abs(a-b); cnt++; }
      }
      const widthRatio=w/pw; if(widthRatio>0.03) continue;
      const meanVar=cnt?varInside/cnt:0; if(meanVar<1.5) continue;
      const sc=(edgeL+edgeR)/(1+Math.abs(meanVar-6));
      if(sc>poleScore){ poleScore=sc; bestPole={x, y:Math.max(ry0,y0), w, h, score:sc}; }
    }

    // æ‰‰è¿‘å‚ã®ç¸¦ç·šã¯ãƒãƒ¼ãƒ«æ‰±ã„ã‚’æŠ‘åˆ¶
    if(bestDoor && bestPole){
      const cx=bestPole.x+bestPole.w/2;
      const inDoorX=(cx>bestDoor.x-6 && cx<bestDoor.x+bestDoor.w+6);
      const overlapY=!(bestPole.y+bestPole.h<bestDoor.y || bestPole.y>bestDoor.y+bestDoor.h);
      if(inDoorX && overlapY){ bestPole=null; }
    }

    // ã‚¹ã‚±ãƒ¼ãƒ«
    const sx=W/pw, sy=H/ph;
    const doorBox=bestDoor?{x:bestDoor.x*sx,y:bestDoor.y*sy,w:bestDoor.w*sx,h:bestDoor.h*sy}:null;
    const poleBox=bestPole?{x:bestPole.x*sx,y:bestPole.y*sy,w:bestPole.w*sx,h:bestPole.h*sy}:null;
    return {door:doorBox, pole:poleBox};
  }

  function redGreenYellow(imgData){
    const d=imgData.data; let rc=0,gc=0,yc=0;
    for(let i=0;i<d.length;i+=4){
      const h=hsvFromRgb(d[i],d[i+1],d[i+2]);
      if(h.v<0.25||h.s<0.35) continue;
      if(h.h<25||h.h>335) rc++; else if(h.h>75&&h.h<170) gc++; else if(h.h>=25&&h.h<=75) yc++;
    }
    const total=rc+gc+yc; if(total<60) return null;
    if(rc>gc && rc>yc) return 'red';
    if(gc>rc && gc>yc) return 'green';
    return 'yellow';
  }

  // ==== Main draw
  function drawDetections(preds){
    ctx.clearRect(0,0,ov.width,ov.height);

    const forwardROI = {x: ov.width*0.33, y: ov.height*0.45, w: ov.width*0.34, h: ov.height*0.42};
    ctx.strokeStyle='rgba(255,255,255,.18)'; ctx.lineWidth=2; ctx.strokeRect(forwardROI.x, forwardROI.y, forwardROI.w, forwardROI.h);

    // 1) é»„ç·š
    const guide = detectYellowGuide();
    if(guide){
      ctx.lineWidth=8; ctx.strokeStyle='rgba(255,212,0,0.95)';
      ctx.beginPath(); ctx.moveTo(guide.x1, guide.y1); ctx.lineTo(guide.x2, guide.y2); ctx.stroke();
      const tag = `é»„ç·šï¼š${angleToClock(guide.ang)}ã¸ç¶šãã¾ã™`;
      ctx.font='700 24px ui-monospace,Menlo,Consolas,monospace';
      const tw = ctx.measureText(tag).width+16;
      ctx.fillStyle='rgba(0,0,0,.65)'; ctx.fillRect(8, 8, tw, 30);
      ctx.fillStyle='var(--guide)'; ctx.fillText(tag, 16, 30);
      sayThrottle('yellow', `${angleToClock(guide.ang)}ã«é»„è‰²ã„ç‚¹å­—ãƒ–ãƒ­ãƒƒã‚¯ã€‚`, 2200);
    }

    // 2) æ¨ªæ–­æ­©é“
    const zebra = detectCrosswalk();
    if(zebra){
      ctx.strokeStyle='rgba(255,255,255,.9)'; ctx.lineWidth=3; ctx.strokeRect(zebra.x,zebra.y,zebra.w,zebra.h);
      sayThrottle('zebra', 'å‰æ–¹ã«æ¨ªæ–­æ­©é“ã€‚', 2500);
    }

    // 3) COCO-SSD
    const Wpx=(v.videoWidth||ov.width);
    const K=parseInt(document.getElementById('topK').value,10)||1;
    const mode=document.getElementById('announceMode').value;
    const allow=(cls)=>{
      if(mode==='all') return true;
      const pv=['person','car','bicycle','bus','motorcycle','truck'];
      const imp=['person','car','bicycle','bus'];
      return mode==='people_vehicles'? pv.includes(cls) : imp.includes(cls);
    };

    const minScore=0.55;
    const items = preds.filter(p=>p.score>=minScore).map(p=>{
      const [x,y,w,h]=p.bbox;
      const cx=x+w/2;
      const ang=((cx - Wpx/2)/(Wpx/2))*(Math.PI/2); // æ–¹ä½ã¯Â±90Â°
      const dist=estimateDistPx(p.bbox,p.class);
      return {...p, ang, dist};
    }).sort((a,b)=>{ const da=a.dist??1e9, db=b.dist??1e9; if(da!==db) return da-db; return b.score-a.score; });

    let said=0;
    items.forEach(p=>{
      const [x,y,w,h]=p.bbox;
      const tagDir=angleToClock(p.ang); const dtxt = p.dist? ` ${p.dist.toFixed(1)}m` : '';
      const tagText = `${tagDir} ${toJa(p.class)}${dtxt}`;

      // æ ã¨ãƒ©ãƒ™ãƒ«
      ctx.font='600 22px ui-monospace,Menlo,Consolas,monospace';
      const textW=ctx.measureText(tagText).width+16; const padH=28;
      let lx = Math.min(Math.max(x, 4), ov.width - textW - 4);
      let ly = (y>=32)? y-4 : y+h+padH+4; if(ly+(-padH) < 0) ly = y+h+padH+4;

      let stroke='rgba(57,255,20,.95)';
      const isObstacle = ['person','car','bicycle','bus','motorcycle','truck','bench','chair','potted plant','stop sign','traffic light'].includes(p.class);
      if(isObstacle) stroke='rgba(255,59,59,.9)';

      ctx.strokeStyle=stroke; ctx.lineWidth=3; ctx.strokeRect(x,y,w,h);
      ctx.fillStyle='rgba(0,0,0,.7)'; ctx.fillRect(lx, ly-padH, textW, padH);
      ctx.fillStyle=stroke==='rgba(255,59,59,.9)'?'#ff7d7d':'#39ff14'; ctx.fillText(tagText, lx+8, ly-7);

      // ä¿¡å·ã®ç¾åœ¨è‰²
      if(p.class==='traffic light'){
        try{
          const crop=ctx.getImageData(x,y,w,h);
          const col=redGreenYellow(crop);
          if(col){
            const msg = col==='red'? 'ä¿¡å·ã¯ä»Šã€èµ¤ã§ã™ã€‚æ­¢ã¾ã£ã¦ãã ã•ã„ã€‚' :
                        col==='green'? 'ä¿¡å·ã¯ä»Šã€é’ã§ã™ã€‚æ¸¡ã‚Œã¾ã™ã€‚' :
                        'ä¿¡å·ã¯ä»Šã€é»„ã§ã™ã€‚æ³¨æ„ã—ã¦ãã ã•ã„ã€‚';
            sayThrottle('tl_'+col, msg, 2400);
          }
        }catch(e){}
      }

      // å‰æ–¹ROIã«å…¥ã‚‹ï¼†å±é™ºè·é›¢ãªã‚‰è­¦å‘Š
      const cx=x+w/2, cy=y+h/2;
      const inROI = (cx>forwardROI.x && cx<forwardROI.x+forwardROI.w && cy>forwardROI.y && cy<forwardROI.y+forwardROI.h);
      const close = p.dist && p.dist < 1.4;
      if(isObstacle && (inROI || close)){
        sayThrottle('haz_'+p.class, `å‰æ–¹ã€${toJa(p.class)}ã€‚${p.dist? Math.max(0.5,p.dist).toFixed(1)+'ãƒ¡ãƒ¼ãƒˆãƒ«ã€‚' : ''}æ³¨æ„ã€‚`, 1300);
      }

      // è¿‘ã„é †ã«ä¸Šä½Kä»¶ã ã‘èª­ã¿ä¸Šã’
      if(said<K && allow(p.class)){
        const distSay = p.dist? `${Math.max(0.5,p.dist).toFixed(1)}ãƒ¡ãƒ¼ãƒˆãƒ«` : '';
        const hazard = (p.class==='person'||p.class==='car'||p.class==='bicycle'||p.class==='bus') && (p.dist && p.dist < 1.2);
        const extra = hazard ? ' æ³¨æ„ã€æ¥è¿‘ã—ã¦ã„ã¾ã™ã€‚' : '';
        const t = `${angleToClock(p.ang)}ã€${distSay? distSay+'ã€' : ''}${toJa(p.class)}ã€‚${extra}`;
        sayThrottle(`obj_${p.class}_${tagDir}`, t, hazard? 1200: 1700);
        said++;
      }
    });

    // 4) è‡ªå‰ï¼šç„é–¢æ‰‰ / ãƒãƒ¼ãƒ«
    const {door, pole} = detectEntranceAndPole();
    if(door){
      ctx.strokeStyle='rgba(255,200,0,.95)'; ctx.lineWidth=3;
      ctx.strokeRect(door.x, door.y, door.w, door.h);
      const ang=((door.x+door.w/2 - ov.width/2)/(ov.width/2))*(Math.PI/2);
      sayThrottle('door', `${angleToClock(ang)}ã€æ‰‰ã€‚`, 2200);
    }
    if(pole){
      ctx.strokeStyle='rgba(255,140,0,.95)'; ctx.lineWidth=3;
      ctx.strokeRect(pole.x, pole.y, pole.w, pole.h);
      const ang=((pole.x+pole.w/2 - ov.width/2)/(ov.width/2))*(Math.PI/2);
      sayThrottle('pole', `${angleToClock(ang)}ã€ãƒãƒ¼ãƒ«ã€‚æ³¨æ„ã€‚`, 2500);
    }
  }

  async function detLoop(){
    if(!model){ ctx.clearRect(0,0,ov.width,ov.height); return; }
    try{ const preds=await model.detect(v); drawDetections(preds); }catch(e){ console.warn(e); }
    detTimer=setTimeout(detLoop, 550);
  }

  // FOVï¼ˆè·é›¢è£œæ­£ã®ã¿ï¼‰
  const fovEl=document.getElementById('fov');
  fovEl.addEventListener('input',()=>{
    toast('FOV '+fovEl.value+'Â°'); sayThrottle('fov_notice','è·é›¢è£œæ­£ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚',1200);
    if(model) { model.detect(v).then(drawDetections).catch(()=>{}); }
  });

  // ==== Boot
  async function startAll(){
    document.getElementById('gate').style.display='none';
    await startCamera();
    toast('ğŸ“¦ ãƒ¢ãƒ‡ãƒ«èª­è¾¼ä¸­â€¦');
    const ok = await loadModelWithFallback();
    if(ok){ toast('âœ… æº–å‚™å®Œäº†'); detLoop(); }
    else { toast('âš  ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸å¯ï¼šãƒãƒƒãƒˆ/CDNã‚’ç¢ºèª'); }
  }
  document.getElementById('gateStart').onclick = ()=>{ startAll().catch(e=>console.error(e)); };
  document.getElementById('startBtn').onclick = ()=>{ startAll().catch(e=>console.error(e)); };
})();
</script>
</body>
</html>
