<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>視覚ガイド — 階段強化・名称読み上げ・欄干対応</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo,sans-serif}
  #root{position:fixed;inset:0}
  video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
  #hud{position:fixed;left:0;right:0;bottom:0;background:#0b0b0cdd;backdrop-filter:blur(2px);padding:8px;display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button,select,input[type=range],label{font-size:14px}
  button{padding:8px 12px;border:0;border-radius:10px;background:#555;color:#fff;opacity:.6}
  button.ready{background:#2e7d32;opacity:1}
  button.stop{background:#c62828}
  #debug{position:fixed;left:8px;top:8px;right:8px;max-height:42vh;overflow:auto;background:#0008;border:1px solid #3a3;padding:6px;border-radius:8px;font:12px/1.4 ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap}
  .badge{display:inline-block;padding:2px 6px;border-radius:6px;background:#111;border:1px solid #444;margin-right:6px}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:90px;background:#e53935;color:#fff;padding:8px 12px;border-radius:10px;font-weight:700;display:none}
  .toast.show{display:block}
</style>
</head>
<body>
<div id="root">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="view"></canvas>
</div>

<div id="debug"></div>
<div id="toast" class="toast">警告</div>

<div id="hud">
  <button id="btn" disabled>開始</button>
  <label><input type="checkbox" id="chkTactile" checked> 点字</label>
  <label><input type="checkbox" id="chkGuard" checked> 汎用ガード</label>
  <label><input type="checkbox" id="chkStair" checked> 階段検出</label>
  <label><input type="checkbox" id="chkPole" checked> ポール検出</label>
  <label>最大件数 <input type="range" id="maxItems" min="1" max="8" value="4"></label>
  <span class="badge" id="badge">準備中…</span>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
<script src="https://docs.opencv.org/4.x/opencv.js" async></script>
<script>
/* ===== 基本ユーティリティ ===== */
const logEl = document.getElementById('debug');
function logOnce(key, ...args){ if(!logOnce._s) logOnce._s=new Set(); if(logOnce._s.has(key)) return; logOnce._s.add(key); log(...args); }
function log(...args){ const t=new Date().toLocaleTimeString(); logEl.textContent += `[${t}] ` + args.join(' ') + '\n'; logEl.scrollTop = logEl.scrollHeight; }
const toast = document.getElementById('toast'); const badge = document.getElementById('badge');
function showToast(msg){ toast.textContent=msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), 1400); }

const btn = document.getElementById('btn');
const chkTactile = document.getElementById('chkTactile');
const chkGuard = document.getElementById('chkGuard');
const chkStair = document.getElementById('chkStair');
const chkPole  = document.getElementById('chkPole');
const maxItems = document.getElementById('maxItems');

const video = document.getElementById('video');
const view = document.getElementById('view');
const ctx = view.getContext('2d');

let running=false, model=null, cvReady=false, allReady=false;

/* ===== TFJS backend ===== */
(async()=>{ try{ await tf.setBackend('webgl').catch(async()=>{ await tf.setBackend('cpu'); }); await tf.ready(); log('TFJS backend:', tf.getBackend()); }catch(e){ log('TFJS init error:', e); } })();

/* ===== OpenCV ready ===== */
const cvReadyPromise = new Promise(res=>{
  if (window.cv && cv.getBuildInformation) {
    cv['onRuntimeInitialized'] = ()=>{ cvReady=true; log('OpenCV ready'); res(); };
  } else { window.Module = { onRuntimeInitialized(){ cvReady=true; log('OpenCV ready'); res(); } }; }
});

/* ===== Camera ===== */
async function initCamera(){
  const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment', width:{ideal:1280}, height:{ideal:720} }, audio:false });
  video.srcObject = stream; await video.play(); resize(); log('Camera initialized', video.videoWidth+'x'+video.videoHeight);
}
function resize(){ view.width = video.videoWidth || view.clientWidth; view.height = video.videoHeight || view.clientHeight; }
addEventListener('resize', resize);

/* ===== TTS ===== */
const READ_FIX = new Map([['方向','ほうこう'],['信号','しんごう'],['進行方向','しんこうほうこう'],['階段','かいだん'],['点字','てんじ']]);
function readFix(s){ for(const [k,v] of READ_FIX) s=s.replaceAll(k,v); return s; }
const lastSpeakAt={};
function speak(text,key,cd=2000){ const now=Date.now(); if(speechSynthesis.speaking) return; if(lastSpeakAt[key] && now-lastSpeakAt[key]<cd) return; lastSpeakAt[key]=now; const u=new SpeechSynthesisUtterance(readFix(text)); u.lang='ja-JP'; speechSynthesis.speak(u); }

/* ===== Helper ===== */
function bearingLabel(cx,cy,W,H){ const dx=cx-W/2, dy=H/2-cy; const deg=(Math.atan2(dy,dx)*180/Math.PI+360)%360; const hour=Math.round(deg/30)||12; return `${hour}じ`; }
function centerAngleDeg(cx,cy,W,H){ const dx=cx-W/2, dy=H/2-cy; return (Math.atan2(dy,dx)*180/Math.PI+360)%360; }
function estDistanceMeters(w,h,W,H){ const area=(w*h)/(W*H); return Math.min(10, Math.max(0.3, 0.6/Math.sqrt(Math.max(area,1e-6)))); }
const LABEL_JA = {
  'traffic light':'信号機','person':'人','bicycle':'自転車','car':'車','bus':'バス','motorcycle':'バイク','truck':'トラック',
  'chair':'いす','couch':'ソファ','dining table':'テーブル','cup':'カップ','bottle':'ボトル','wine glass':'グラス','dog':'いぬ','cat':'ねこ','laptop':'ノート','mouse':'マウス'
};

/* ===== 点字（黄HSV） ===== */
function detectTactile(src){
  if(!cvReady) return [];
  let rgb=new cv.Mat(); cv.cvtColor(src,rgb,cv.COLOR_RGBA2RGB);
  let hsv=new cv.Mat(); cv.cvtColor(rgb,hsv,cv.COLOR_RGB2HSV); rgb.delete();
  let lo=new cv.Mat(hsv.rows,hsv.cols,hsv.type(),[15,90,80,0]);
  let hi=new cv.Mat(hsv.rows,hsv.cols,hsv.type(),[42,255,255,255]);
  let mask=new cv.Mat(); cv.inRange(hsv,lo,hi,mask); lo.delete(); hi.delete(); hsv.delete();
  const h=mask.rows,w=mask.cols; const floorH=Math.floor(h*0.55);
  let roiMask=cv.Mat.zeros(h,w,cv.CV_8UC1); roiMask.roi(new cv.Rect(0,h-floorH,w,floorH)).setTo(new cv.Scalar(255));
  cv.bitwise_and(mask,roiMask,mask); roiMask.delete();
  let k=cv.Mat.ones(5,5,cv.CV_8U); cv.morphologyEx(mask,mask,cv.MORPH_OPEN,k); cv.morphologyEx(mask,mask,cv.MORPH_CLOSE,k); k.delete();
  let contours=new cv.MatVector(), hier=new cv.Mat(); cv.findContours(mask,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE); mask.delete(); hier.delete();
  let out=[];
  for(let i=0;i<contours.size();i++){ const r=cv.boundingRect(contours.get(i)); const ar=(r.width*r.height)/(w*h); const asp=r.width/(r.height+1e-6);
    if(ar>0.002 && ar<0.20 && asp>1.2 && asp<8.0) out.push({x:r.x,y:r.y,w:r.width,h:r.height,label:'点字ブロック',prio:2});
  } contours.delete(); return out;
}

/* ===== 階段（厳格＋金属階段の緩和） ===== */
function detectStairsStrict(src){ // 既存
  const W=src.cols,H=src.rows, y0=Math.floor(H*0.60), hh=Math.max(24,Math.floor(H*0.40));
  let roi=src.roi(new cv.Rect(0,y0,W,hh)); let g=new cv.Mat(); cv.cvtColor(roi,g,cv.COLOR_RGBA2GRAY); cv.equalizeHist(g,g); cv.GaussianBlur(g,g,new cv.Size(3,3),0);
  let edges=new cv.Mat(); cv.Canny(g,edges,60,120);
  let hist=new Array(roi.rows).fill(0); for(let y=0;y<roi.rows;y++)for(let x=0;x<roi.cols;x++) if(edges.ucharPtr(y,x)[0]) hist[y]++;
  let peaks=0,th=Math.max(30,0.15*W),maxRow=0; for(let y=2;y<hist.length-2;y++){ if(hist[y]>hist[y-1]&&hist[y]>hist[y+1]&&hist[y]>th){ peaks++; maxRow=Math.max(maxRow,hist[y]); } }
  g.delete(); edges.delete(); roi.delete();
  if(peaks>=8 && maxRow>0.60*W) return {x:Math.floor(W*0.05),y:y0,w:Math.floor(W*0.90),h:hh,label:'階段',prio:1};
  return null;
}
function detectStairsMetal(src){ // 金属・スケルトン階段
  const W=src.cols,H=src.rows, y0=Math.floor(H*0.55), hh=Math.max(24,Math.floor(H*0.45));
  let roi=src.roi(new cv.Rect(0,y0,W,hh)); let g=new cv.Mat(); cv.cvtColor(roi,g,cv.COLOR_RGBA2GRAY); cv.GaussianBlur(g,g,new cv.Size(3,3),0);
  let edges=new cv.Mat(); cv.Canny(g,edges,40,100);
  // Probabilistic Hough で長い水平線を数える
  let lines=new cv.Mat(); cv.HoughLinesP(edges,lines,1,Math.PI/180,40, Math.max(30, W*0.25), 10);
  let count=0, cover=0;
  for(let i=0;i<lines.rows;i++){
    const [x1,y1,x2,y2]=lines.intPtr(i);
    const dy=Math.abs(y1-y2), dx=Math.abs(x1-x2);
    if(dy<=3 && dx>W*0.4){ count++; cover=Math.max(cover,dx); }
  }
  g.delete(); edges.delete(); lines.delete(); roi.delete();
  if(count>=5 && cover>W*0.4) return {x:Math.floor(W*0.05),y:y0,w:Math.floor(W*0.90),h:hh,label:'階段',prio:1};
  return null;
}

/* ===== ポール & 欄干まとめ ===== */
function detectPoles(src){
  const W=src.cols,H=src.rows;
  let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
  let blur=new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
  let edges=new cv.Mat(); cv.Canny(blur, edges, 70, 140);
  let contours=new cv.MatVector(), hier=new cv.Mat(); cv.findContours(edges,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
  gray.delete(); blur.delete(); edges.delete(); hier.delete();
  let poles=[];
  for(let i=0;i<contours.size();i++){
    const r=cv.boundingRect(contours.get(i));
    const area=(r.width*r.height)/(W*H); const aspect=r.height/(r.width+1e-6); const bottom=r.y+r.height;
    if(area>0.0005 && area<0.03 && aspect>3.0 && r.width < W*0.12 && bottom>H*0.50) poles.push({x:r.x,y:r.y,w:r.width,h:r.height});
  }
  contours.delete();
  if(poles.length>=3){
    // 近接クラスタをまとめて柵扱い
    const minX=Math.min(...poles.map(p=>p.x)), maxX=Math.max(...poles.map(p=>p.x+p.w));
    const minY=Math.min(...poles.map(p=>p.y)), maxY=Math.max(...poles.map(p=>p.y+p.h));
    if((maxX-minX) < W*0.6){ // 一帯に集中＝欄干
      return [{x:minX,y:minY,w:maxX-minX,h:maxY-minY,label:'手すり/柵',prio:2, fence:true}];
    }
  }
  return poles.map(p=>({...p,label:'ポール',prio:3}));
}

/* ===== 平面（壁/扉） ===== */
function detectPlanar(src){
  const W=src.cols,H=src.rows; let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
  let blur=new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(9,9), 0);
  let edges=new cv.Mat(); cv.Canny(blur, edges, 60, 120);
  const edgeRatio=cv.countNonZero(edges)/(W*H); let m=new cv.Mat(), s=new cv.Mat(); cv.meanStdDev(blur,m,s); const sigma=s.data64F[0];
  gray.delete(); m.delete(); s.delete();
  if(edgeRatio<0.06 && sigma<40){
    const cx=Math.floor(W*0.15), cy=Math.floor(H*0.15), cw=Math.floor(W*0.70), ch=Math.floor(H*0.70);
    blur.delete(); edges.delete(); return {x:cx,y:cy,w:cw,h:ch,label:'正面の平面（壁/扉）',prio:0};
  }
  blur.delete(); edges.delete(); return null;
}

/* ===== 信号色（青広め） ===== */
function classifyTrafficLight(src, box){
  const x=Math.max(0,box.x|0), y=Math.max(0,box.y|0), w=Math.max(2,box.w|0), h=Math.max(2,(box.h/2)|0);
  const rect=new cv.Rect(x,y,w,h); const roi=src.roi(rect);
  let rgb=new cv.Mat(); cv.cvtColor(roi,rgb,cv.COLOR_RGBA2RGB);
  let hsv=new cv.Mat(); cv.cvtColor(rgb,hsv,cv.COLOR_RGB2HSV); rgb.delete();
  const mk=(a,b)=>{ let lo=new cv.Mat(hsv.rows,hsv.cols,hsv.type(),a), hi=new cv.Mat(hsv.rows,hsv.cols,hsv.type(),b), m=new cv.Mat(); cv.inRange(hsv,lo,hi,m); lo.delete(); hi.delete(); return m; };
  let red1=mk([0,110,80,0],[10,255,255,255]), red2=mk([170,110,80,0],[180,255,255,255]); let red=new cv.Mat(); cv.add(red1,red2,red); red1.delete(); red2.delete();
  let green=mk([35,80,80,0],[85,255,255,255]); let blue=mk([85,80,80,0],[140,255,255,255]); let yellow=mk([15,110,90,0],[35,255,255,255]);
  const cnt=m=>cv.countNonZero(m); const sr=cnt(red), sg=cnt(green), sb=cnt(blue), sy=cnt(yellow); red.delete(); green.delete(); blue.delete(); yellow.delete(); hsv.delete(); roi.delete();
  const maxv=Math.max(sr,sg,sb,sy); if(maxv<5) return null; if(maxv===sr) return '赤'; if(maxv===sy) return '黄'; if(maxv===sg||maxv===sb) return '青'; return null;
}

/* ===== 安定化（2フレーム） ===== */
let trackBuf=[]; function iou(a,b){ const x1=Math.max(a.x,b.x),y1=Math.max(a.y,b.y),x2=Math.min(a.x+a.w,b.x+b.w),y2=Math.min(a.y+a.h,b.y+b.h); const inter=Math.max(0,x2-x1)*Math.max(0,y2-y1); const u=a.w*a.h+b.w*b.h-inter; return u?inter/u:0; }
function stabilize(dets){
  const now=performance.now();
  dets.forEach(d=>{ let m=trackBuf.find(t=>t.label===d.label && iou(t,d)>0.5); if(m){ Object.assign(m,d); m.count=Math.min(m.count+1,5); m.ts=now; } else { trackBuf.push({...d,count:1,ts:now}); } });
  trackBuf=trackBuf.filter(t=> now-t.ts<900);
  return trackBuf.filter(t=>t.count>=2).sort((a,b)=>(a.prio??5)-(b.prio??5));
}

/* ===== メイン ===== */
let off=document.createElement('canvas'), ofx=off.getContext('2d');
let clearFrames=0;

async function runLoop(){
  if(!running) return;
  resize(); const W=view.width,H=view.height; ctx.drawImage(video,0,0,W,H);
  if(!model){ requestAnimationFrame(runLoop); return; }

  const iw=256, ih=Math.max(1,Math.floor(H*(256/Math.max(1,W)))); off.width=iw; off.height=ih; ofx.drawImage(video,0,0,iw,ih);

  let t0=performance.now(); let raw=[];
  try{ raw = await model.detect(off); }catch(e){ logOnce('detect-error','detect error:', e?.message||e); }
  raw = raw.filter(p=>p && p.score>=0.6).sort((a,b)=>b.score-a.score).slice(0, +maxItems.value);

  const sx=W/iw, sy=H/ih;
  let dets = raw.map(p=>{ let [x,y,w,h]=p.bbox; x*=sx; y*=sy; w*=sx; h*=sy; return {x,y,w,h,label:(LABEL_JA[p.class]||p.class),prio:4,raw:p.class}; });

  if(cvReady){
    const src=cv.imread(view);

    // 点字
    if(chkTactile.checked) dets.push(...detectTactile(src));

    // 階段（厳格 or 緩和どちらか）
    if(chkStair.checked){
      const s1=detectStairsStrict(src); const s2=detectStairsMetal(src);
      if(s1) dets.push(s1); else if(s2) dets.push(s2);
    }

    // ポール/欄干
    if(chkPole.checked) dets.push(...detectPoles(src));

    // 信号色
    for(const d of dets){ if(d.raw==='traffic light'||d.label==='信号機'){ const c=classifyTrafficLight(src,d); if(c){ d.label=`信号機（${c}）`; d.prio=1; speak(`${c} しんごう です`,'sig_'+c,1600);} } }

    src.delete();
  }

  // 個別・即時読み上げ：単独ポール（8m ±60°）
  for(const d of dets){ if(d.label==='ポール'){ const dist=estDistanceMeters(d.w,d.h,W,H); const off=Math.min(Math.abs(centerAngleDeg(d.x+d.w/2,d.y+d.h/2,W,H)), 360); if(dist<8 && off<=60) speak('ポール ちゅうい','pole_fast',1800); } }

  // 安定化
  let stable = stabilize(dets);

  // 競合：点字優先
  stable = stable.filter((a,i,arr)=> a.label!=='点字ブロック' || arr.findIndex(b=>b.label==='階段' && iou(a,b)>0.5)===-1 );

  // 物の名前を読む（中心50%・2.5m以内）
  for(const d of stable){
    if(['信号機（赤）','信号機（青）','信号機（黄）','階段','点字ブロック','手すり/柵','ポール'].includes(d.label)) continue;
    if(LABEL_JA[d.raw] || ['cup','bottle','wine glass','chair','dining table','laptop','mouse','dog','cat'].includes(d.raw)){
      const cx=d.x+d.w/2, cy=d.y+d.h/2, dist=estDistanceMeters(d.w,d.h,W,H);
      if(cx>W*0.25 && cx<W*0.75 && dist<2.5){ const name=LABEL_JA[d.raw]||d.label; speak(`${name} あります`, 'obj_'+(LABEL_JA[d.raw]||d.raw), 2200); }
    }
  }

  // 汎用ガード（至近のみ）
  let danger=null;
  if(chkGuard.checked){
    if(cvReady){ const src=cv.imread(view); const planar=detectPlanar(src); src.delete(); if(planar) danger={box:planar,message:'正面に壁や扉があります'}; }
    if(!danger){
      for(const d of stable){
        const dist=estDistanceMeters(d.w,d.h,W,H); const bottom=d.y+d.h;
        if(dist<0.8 && bottom>H*0.92){ danger={box:d,message:'すぐ前に障害物、注意'}; break; }
      }
    }
  }

  // 描画
  ctx.lineWidth=4; ctx.font=`${Math.max(16,Math.floor(W*0.032))}px system-ui`;
  for(const d of stable){
    let color='rgba(0,255,0,.9)';
    if(d.label.startsWith('信号機（赤')) color='#ff8a80';
    else if(d.label.startsWith('信号機（青')) color='#80d8ff';
    else if(d.label.startsWith('信号機（黄')) color='#ffe082';
    else if(d.label==='点字ブロック') color='#ffa726';
    else if(d.label==='階段') color='#42a5f5';
    else if(d.label==='ポール') color='#f06292';
    else if(d.label==='手すり/柵') color='#ef9a9a';
    ctx.strokeStyle=color; ctx.fillStyle='rgba(0,0,0,.55)';
    ctx.strokeRect(d.x,d.y,d.w,d.h);
    const angle=bearingLabel(d.x+d.w/2,d.y+d.h/2,W,H), dist=estDistanceMeters(d.w,d.h,W,H).toFixed(1);
    const text=`${angle} ほうこう  ${d.label}  ${dist}m`; const tw=ctx.measureText(text).width+10;
    ctx.fillRect(d.x,Math.max(0,d.y-24),tw,24);
    ctx.fillStyle='#e0ffe0'; if(d.label==='点字ブロック') ctx.fillStyle='#ffd27f';
    if(d.label==='階段') ctx.fillStyle='#bbdefb'; if(d.label==='ポール') ctx.fillStyle='#f8bbd0'; if(d.label==='手すり/柵') ctx.fillStyle='#ffcdd2';
    ctx.fillText(text,d.x+5,d.y-6);
    if(d.label==='階段') speak('まえ かいだん ちゅうい','stairs',2000);
    if(d.label==='手すり/柵') speak('てすり ちゅうい','fence',2500);
    if(d.label==='点字ブロック'){ const cx=d.x+d.w/2; if(cx>W*0.2 && cx<W*0.8) speak('てんじブロック あります。なぞって すすみます','tactile',3000); }
  }

  if(danger){ const b=danger.box; ctx.strokeStyle='#ff5252'; ctx.lineWidth=6; ctx.strokeRect(b.x,b.y,b.w,b.h); showToast(danger.message); speak(danger.message,'danger',1600); clearFrames=0; }

  // 進行方向クリア
  const centerSafe = !danger && stable.every(d=>{ const deg=centerAngleDeg(d.x+d.w/2,d.y+d.h/2,W,H); const off=Math.min(Math.abs(deg),360-Math.abs(deg)); const dist=estDistanceMeters(d.w,d.h,W,H); return !(off<=30 && dist<5); });
  clearFrames = centerSafe ? Math.min(clearFrames+1,999) : 0;
  if(clearFrames>=6){ speak('しんこうほうこう 5メートル あんぜんです','clear',3800); clearFrames=0; }

  badge.textContent = `FPS:${(1000/(performance.now()-t0)).toFixed(1)}  安定:${stable.length}`;
  if(running) requestAnimationFrame(runLoop);
}

/* ===== 起動 ===== */
(async function (){
  try{
    badge.textContent='カメラ起動中…'; await initCamera();
    badge.textContent='モデル読込中…'; model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
    badge.textContent='OpenCV初期化中…'; await cvReadyPromise;
    allReady=true; btn.disabled=false; btn.classList.add('ready');
    badge.textContent='準備完了：開始で実行';
    log('階段（厳格+金属対応）/ 名称読み上げ / 欄干まとめ を有効化');
  }catch(e){ log('初期化エラー:', e); badge.textContent='エラー：上のログを確認'; }
})();
btn.onclick=()=>{ if(!allReady){ logOnce('not-ready','準備中'); return; } if(!running){ running=true; btn.textContent='停止'; btn.classList.add('stop'); requestAnimationFrame(runLoop); } else { running=false; btn.textContent='開始'; btn.classList.remove('stop'); } };
</script>
</body>
</html>
