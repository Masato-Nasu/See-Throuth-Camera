<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>視覚支援AR：点字ブロックガイド / 信号 / 障害物 読み上げ</title>
  <meta name="description" content="点字ブロック（線状・点状）を検出して進行方向を案内。信号機の赤/青、前方の障害物も日本語で読み上げます。" />
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.19.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
  <style>
    :root{ --green:#39ff14; --text:#e8ffe8; --warn:#ff3b3b; --guide:#ffd400; }
    html,body{ margin:0; height:100%; background:#000; color:var(--text); font-family:ui-monospace,Menlo,Consolas,monospace; overflow:hidden }
    #wrap{ position:fixed; inset:0; }
    video{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover }
    canvas{ position:absolute; inset:0; pointer-events:none }
    #controls{
      position:fixed; left:0; right:0; bottom:0; display:flex; flex-wrap:wrap; gap:10px;
      padding:8px calc(10px + env(safe-area-inset-right)) calc(8px + env(safe-area-inset-bottom)) calc(10px + env(safe-area-inset-left));
      background:rgba(0,0,0,0.15); border-top:1px solid rgba(57,255,20,.25); overflow-x:auto; -webkit-overflow-scrolling:touch; z-index:5
    }
    .label{ color:var(--green); font-size:12px; margin:0 4px }
    .range, select, .btn{ border:1px solid rgba(57,255,20,.45); background:rgba(0,0,0,.25); color:var(--text); border-radius:10px; padding:6px 10px; white-space:nowrap }
    .btn{ cursor:pointer }
    #gate{ position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.9); color:var(--text); z-index:10; text-align:center; gap:14px; padding:20px }
    #toast{ position:fixed; left:50%; transform:translateX(-50%); top:10px; padding:8px 12px; border:1px solid rgba(57,255,20,.5); border-radius:10px; background:rgba(0,0,0,.55); color:var(--green); display:none; z-index:20 }
  </style>
  <link rel="icon" href="data:," />
</head>
<body>
  <div id="toast"></div>
  <div id="wrap">
    <video id="v" autoplay playsinline muted></video>
    <canvas id="ov"></canvas>
    <!-- 低解像度処理用（非表示） -->
    <canvas id="proc" width="160" height="96" style="display:none"></canvas>
  </div>
  <div id="controls">
    <button class="btn" id="startBtn">▶︎ 開始</button>
    <span class="label">FOV°</span><input class="range" id="fov" type="range" min="45" max="95" value="70" />
    <span class="label">読み上げ</span>
    <select id="announceMode">
      <option value="important">重要のみ（人・車・自転車・バス）</option>
      <option value="people_vehicles">人＋乗り物</option>
      <option value="all">すべて</option>
    </select>
    <span class="label">最大件数</span><input class="range" id="topK" type="range" min="1" max="3" value="1" />
  </div>
  <div id="gate">
    <div>
      <h2 style="color:#39ff14;margin:0 0 6px">カメラへのアクセスが必要です</h2>
      <p style="margin:0 0 12px">HTTPSで開いてください。開始で背面カメラ＋HUDが起動します。</p>
      <button class="btn" id="gateStart">開始 / START</button>
    </div>
  </div>

<script>
(async()=>{
  const v = document.getElementById('v');
  const ov = document.getElementById('ov');
  const ctx = ov.getContext('2d');
  const proc = document.getElementById('proc');
  const pctx = proc.getContext('2d');

  const toast=(m)=>{ const t=document.getElementById('toast'); t.textContent=m; t.style.display='block'; clearTimeout(toast._t); toast._t=setTimeout(()=>t.style.display='none', 2400); };

  let model=null, detTimer=null;

  // ===== Utils
  const synth=window.speechSynthesis; const lastMap=new Map();
  function speak(t){ if(synth.speaking) return; const u=new SpeechSynthesisUtterance(t); u.lang='ja-JP'; u.rate=1; synth.speak(u); }
  function sayThrottle(key, text, cd=1600){ const now=performance.now(), last=lastMap.get(key)||0; if(now-last>cd){ lastMap.set(key, now); speak(text); } }
  function resize(){ const w=v.videoWidth||v.clientWidth||innerWidth; const h=v.videoHeight||v.clientHeight||innerHeight; ov.width=w; ov.height=h; }
  function angleToClock(ang){ const deg=ang*180/Math.PI; const off=Math.round(deg/30); let hour=(12+off)%12; if(hour===0) hour=12; return hour+'時方向'; }

  const TYPICAL_H={ person:1.7, bicycle:1.05, car:1.45, bus:3.0, truck:2.5, motorcycle:1.2, dog:0.5, cat:0.26, chair:0.9, bottle:0.25, cup:0.1, laptop:0.3, 'traffic light':0.6, 'wine glass':0.18 };
  function focalPx(w,fovDeg){ const f=fovDeg*Math.PI/180; return (0.5*w)/Math.tan(f/2); }
  function estimateDistPx(bbox, cls){ const h=bbox[3]; const H=TYPICAL_H[cls]||0.3; if(h<=1) return null; const W=(v.videoWidth||ov.width); const F=focalPx(W, parseInt(document.getElementById('fov').value,10)); return (H*F)/h; }

  function hsvFromRgb(r,g,b){ r/=255; g/=255; b/=255; const M=Math.max(r,g,b), m=Math.min(r,g,b); let h=0,s=0,vv=M, d=M-m; s=M===0?0:d/M; if(M!==m){ switch(M){ case r:h=(g-b)/d+(g<b?6:0);break; case g:h=(b-r)/d+2;break; case b:h=(r-g)/d+4; } h/=6; } return {h:h*360,s,v:vv}; }
  function redOrGreen(imgData){ const d=imgData.data; let rc=0,gc=0; for(let i=0;i<d.length;i+=4){ const h=hsvFromRgb(d[i],d[i+1],d[i+2]); if(h.v<0.2||h.s<0.35) continue; if(h.h<25||h.h>335) rc++; else if(h.h>75&&h.h<170) gc++; } if(rc+gc<50) return null; return rc>gc?'red':'green'; }

  // ===== Model
  async function loadModelWithFallback(){
    try{ model=await cocoSsd.load({base:'lite_mobilenet_v2'}); return true; }
    catch(e1){
      try{ await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://unpkg.com/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js'; s.onload=res; s.onerror=rej; document.head.appendChild(s); }); model=await cocoSsd.load({base:'lite_mobilenet_v2'}); return true; }
      catch(e2){ console.warn('[A11yAR] coco-ssd load failed', e1, e2); return false; }
    }
  }

  async function startCamera(){
    if(!window.isSecureContext && location.hostname!=='localhost' && location.hostname!=='127.0.0.1'){
      toast('⚠ HTTPSが必要です（または localhost）'); throw new Error('Insecure');
    }
    const stream=await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ ideal:'environment' } }, audio:false });
    v.srcObject=stream; await new Promise(res=> v.onloadedmetadata=res); await v.play(); resize(); addEventListener('resize', resize); toast('📷 カメラ起動');
  }

  // ===== Japanese labels
  function toJa(cls){
    const map={
      person:'人', bicycle:'自転車', car:'車', motorcycle:'バイク', airplane:'飛行機', bus:'バス', train:'電車', truck:'トラック', boat:'ボート',
      'traffic light':'信号', 'fire hydrant':'消火栓', 'stop sign':'一時停止標識', 'parking meter':'パーキングメーター', bench:'ベンチ',
      bird:'鳥', cat:'猫', dog:'犬', horse:'馬', sheep:'羊', cow:'牛', elephant:'象', bear:'熊', zebra:'シマウマ', giraffe:'キリン',
      backpack:'リュック', umbrella:'傘', handbag:'ハンドバッグ', tie:'ネクタイ', suitcase:'スーツケース',
      frisbee:'フリスビー', skis:'スキー板', snowboard:'スノーボード', 'sports ball':'ボール', kite:'凧', 'baseball bat':'バット', 'baseball glove':'グローブ', skateboard:'スケートボード', surfboard:'サーフボード', 'tennis racket':'テニスラケット',
      bottle:'ボトル', 'wine glass':'ワイングラス', cup:'カップ', fork:'フォーク', knife:'ナイフ', spoon:'スプーン', bowl:'ボウル',
      banana:'バナナ', apple:'りんご', sandwich:'サンドイッチ', orange:'オレンジ', broccoli:'ブロッコリー', carrot:'にんじん', 'hot dog':'ホットドッグ', pizza:'ピザ', donut:'ドーナツ', cake:'ケーキ',
      chair:'椅子', couch:'ソファ', 'potted plant':'観葉植物', bed:'ベッド', 'dining table':'ダイニングテーブル', toilet:'トイレ',
      tv:'テレビ', laptop:'ノートPC', mouse:'マウス', remote:'リモコン', keyboard:'キーボード', 'cell phone':'スマホ',
      microwave:'電子レンジ', oven:'オーブン', toaster:'トースター', sink:'流し台', refrigerator:'冷蔵庫',
      book:'本', clock:'時計', vase:'花瓶', scissors:'はさみ', 'teddy bear':'ぬいぐるみ', 'hair drier':'ドライヤー', toothbrush:'歯ブラシ'
    };
    return map[cls]||cls;
  }

  // ===== 点字ブロック専用 検出（線状/点状）
  function detectTactileGuide(){
    const W = ov.width, H = ov.height;
    const pw = proc.width, ph = proc.height;

    // 下半分を低解像度へ
    pctx.drawImage(v, 0, 0, pw, ph);
    const img = pctx.getImageData(0, 0, pw, ph);
    const d = img.data;

    // 1) 黄色マスク（やや厳しめ） H:32..58°, S>0.45, V>0.45
    const mask = new Uint8Array(pw*ph);
    const yStart = (ph*0.42)|0;
    const pts = [];
    for(let y=yStart; y<ph; y++){
      for(let x=0; x<pw; x++){
        const i = (y*pw + x)*4;
        const r=d[i], g=d[i+1], b=d[i+2];
        const M=Math.max(r,g,b)/255, m=Math.min(r,g,b)/255;
        const v=M, s=M===0?0:(M-m)/M;
        let h=0;
        if(M!==m){
          if(M===r/255) h=((g-b)/(M-m)+(g<b?6:0))/6;
          else if(M===g/255) h=((b-r)/(M-m)+2)/6;
          else h=((r-g)/(M-m)+4)/6;
        }
        h*=360;
        if(h>32 && h<58 && s>0.45 && v>0.45){
          mask[y*pw+x]=1; pts.push([x,y]);
        }
      }
    }
    if(pts.length < 150) return null;

    // 2) 線状ブロック仮説：x = a*y + b
    let sumY=0,sumX=0,sumYY=0,sumYX=0;
    for(const [x,y] of pts){ sumY+=y; sumX+=x; sumYY+=y*y; sumYX+=y*x; }
    const n=pts.length, denom=(n*sumYY - sumY*sumY)||1;
    const a=(n*sumYX - sumY*sumX)/denom, b=(sumX - a*sumY)/n;

    // 帯幅（半幅）を推定
    let acc=0, cnt=0;
    for(const [x,y] of pts){ const xOn=a*y+b; acc+=Math.abs(x-xOn); cnt++; }
    const bandPx = (acc/cnt);
    const bandPxScaled = bandPx * (W/pw);
    const minBand = H*0.01, maxBand = H*0.10;
    const looksLikeBand = (bandPxScaled>minBand && bandPxScaled<maxBand);

    // 3) リブ周期チェック（簡易自己相関）
    function autocorr(sig, minLag, maxLag){
      let bestLag=minLag, bestScore=0;
      for(let lag=minLag; lag<=maxLag; lag++){
        let num=0, den1=0, den2=0;
        for(let i=0;i<sig.length-lag;i++){
          const a=sig[i]-0.5, b=sig[i+lag]-0.5;
          num+=a*b; den1+=a*a; den2+=b*b;
        }
        const s = num / Math.sqrt((den1||1)*(den2||1));
        if(s>bestScore){ bestScore=s; bestLag=lag; }
      }
      return {bestLag, bestScore};
    }
    const ny = 1/Math.sqrt(1+a*a), nx = -a*ny; // 法線ベクトル（proc座標）
    let stripeScoreSum=0, stripeCnt=0;
    for(let sy=ph*0.55|0; sy<ph-4; sy+=Math.max(6, bandPx|0)){
      const sx = a*sy + b;
      const half = Math.max(8, Math.min(24, (bandPx*3)|0));
      const L = half*2+1;
      const prof = new Float32Array(L);
      for(let t=-half, k=0; t<=half; t++, k++){
        const px = sx + nx*t, py = sy + ny*t;
        const ix = Math.max(0, Math.min(pw-1, Math.round(px)));
        const iy = Math.max(0, Math.min(ph-1, Math.round(py)));
        prof[k] = mask[iy*pw+ix] ? 1 : 0;
      }
      const {bestScore} = autocorr(prof, 2, 12); // 2〜12px 周期
      if(bestScore>0.28){ stripeScoreSum += bestScore; stripeCnt++; }
    }
    const ribbedOK = stripeCnt>0 && (stripeScoreSum/stripeCnt) > 0.30;

    // 4) 点状ブロック（交差点）判定：遷移密度
    pctx.drawImage(v, 0, 0, pw, ph);
    const gray = new Uint8Array(pw*ph);
    const dd = pctx.getImageData(0,0,pw,ph).data;
    for(let i=0,j=0;i<dd.length;i+=4,j++) gray[j]=(dd[i]*0.299+dd[i+1]*0.587+dd[i+2]*0.114)|0;

    let dotScore=0, areaCnt=0, y0=(ph*0.55)|0, y1=(ph*0.85)|0, x0=(pw*0.25)|0, x1=(pw*0.75)|0;
    for(let y=y0;y<y1;y+=2){
      for(let x=x0;x<x1;x+=2){
        const m = mask[y*pw+x];
        if(m){
          let transitions=0;
          const nbr=[-1,0,1, -pw, pw];
          for(const off of nbr){
            const nxy = (y*pw+x)+off;
            if(nxy>0 && nxy<pw*ph && mask[nxy]!==m) transitions++;
          }
          if(transitions>=2) dotScore++;
        }
        areaCnt++;
      }
    }
    const areaRatio = pts.length / (pw*ph);
    const dotsOK = (dotScore>200 && areaRatio>0.04);

    const tactileOK = (looksLikeBand && ribbedOK) || dotsOK;
    if(!tactileOK) return null;

    // 画面へ射影（ガイド線2点）
    const y1s = (H*0.55)|0, y2s = H-4;
    const scaleX = W/pw, scaleY = H/ph;
    const x1s = (a*(y1s/scaleY) + b) * scaleX;
    const x2s = (a*(y2s/scaleY) + b) * scaleX;

    const cx = (x1s+x2s)/2;
    const ang = ((cx - W/2) / (W/2)) * (Math.PI/2); // 方位は±90°固定

    return {x1:x1s, y1:y1s, x2:x2s, y2:y2s, ang};
  }

  // ===== メイン描画
  function drawDetections(preds){
    ctx.clearRect(0,0,ov.width,ov.height);

    // 1) 点字ブロックガイド
    const guide = detectTactileGuide();
    if(guide){
      ctx.lineWidth=8; ctx.strokeStyle='rgba(255,212,0,0.9)';
      ctx.beginPath(); ctx.moveTo(guide.x1, guide.y1); ctx.lineTo(guide.x2, guide.y2); ctx.stroke();

      const tag = angleToClock(guide.ang);
      ctx.font='700 24px ui-monospace,Menlo,Consolas,monospace';
      const txt = `点字ブロック：${tag} に延びています`;
      const tw = ctx.measureText(txt).width+16;
      ctx.fillStyle='rgba(0,0,0,.65)'; ctx.fillRect(8, 8, tw, 30);
      ctx.fillStyle='var(--guide)'; ctx.fillText(txt, 16, 30);
      sayThrottle('yellow', `${tag}に点字ブロック。なぞって進めます。`, 2000);
    }

    // 2) COCO-SSD（障害物/信号）
    const Wpx=(v.videoWidth||ov.width);
    const K=parseInt(document.getElementById('topK').value,10)||1;
    const mode=document.getElementById('announceMode').value;
    const allow=(cls)=>{
      if(mode==='all') return true;
      const pv=['person','car','bicycle','bus','motorcycle','truck'];
      const imp=['person','car','bicycle','bus'];
      return mode==='people_vehicles'? pv.includes(cls) : imp.includes(cls);
    };

    const minScore=0.55;
    const items = preds.filter(p=>p.score>=minScore).map(p=>{
      const [x,y,w,h]=p.bbox;
      const cx=x+w/2;
      const ang=((cx - Wpx/2)/(Wpx/2))*(Math.PI/2); // 方位は±90°固定
      const dist=estimateDistPx(p.bbox,p.class);
      return {...p, ang, dist};
    }).sort((a,b)=>{ const da=a.dist??1e9, db=b.dist??1e9; if(da!==db) return da-db; return b.score-a.score; });

    let said=0;
    const forwardROI = {x: ov.width*0.35, y: ov.height*0.45, w: ov.width*0.30, h: ov.height*0.40};

    items.forEach(p=>{
      const [x,y,w,h]=p.bbox;
      // 枠
      ctx.strokeStyle='rgba(57,255,20,.95)'; ctx.lineWidth=3; ctx.strokeRect(x,y,w,h);

      // ラベル
      const tagDir=angleToClock(p.ang); const dtxt = p.dist? ` ${p.dist.toFixed(1)}m` : '';
      const tagText = `${tagDir} ${toJa(p.class)}${dtxt}`;
      ctx.font='600 22px ui-monospace,Menlo,Consolas,monospace';
      const textW=ctx.measureText(tagText).width+16; const padH=28;
      let lx = Math.min(Math.max(x, 4), ov.width - textW - 4);
      let ly = (y>=32)? y-4 : y+h+padH+4; if(ly+(-padH) < 0) ly = y+h+padH+4;
      ctx.fillStyle='rgba(0,0,0,.7)'; ctx.fillRect(lx, ly-padH, textW, padH);
      ctx.fillStyle='#39ff14'; ctx.fillText(tagText, lx+8, ly-7);

      // 信号の色
      if(p.class==='traffic light'){
        try{
          const crop=ctx.getImageData(x,y,w,h);
          const col=redOrGreen(crop);
          if(col){
            const msg = col==='red'? '信号は赤です。止まってください。' : '信号は青です。渡れます。';
            const withD = `${angleToClock(p.ang)}、${p.dist? (Math.max(0.5,p.dist).toFixed(1)+'メートル、') : ''}${msg}`;
            sayThrottle('tl_'+col, withD, 2400);
          }
        }catch(e){}
      }

      // 前方ROIに入る＆危険距離なら警告
      const isObstacle = ['person','car','bicycle','bus','motorcycle','truck','bench','chair','potted plant','stop sign','traffic light'].includes(p.class);
      const cx=x+w/2, cy=y+h/2;
      const inROI = (cx>forwardROI.x && cx<forwardROI.x+forwardROI.w && cy>forwardROI.y && cy<forwardROI.y+forwardROI.h);
      const close = p.dist && p.dist < 1.5;
      if(isObstacle && (inROI || close)){
        ctx.strokeStyle='rgba(255,59,59,.9)'; ctx.lineWidth=4; ctx.strokeRect(x,y,w,h);
        sayThrottle('haz_'+p.class, `前方、${toJa(p.class)}。${p.dist? Math.max(0.5,p.dist).toFixed(1)+'メートル。' : ''}注意。`, 1300);
      }

      // 近い順に上位K件だけ読み上げ
      if(said<K && allow(p.class)){
        const distSay = p.dist? `${Math.max(0.5,p.dist).toFixed(1)}メートル` : '';
        const hazard = (p.class==='person'||p.class==='car'||p.class==='bicycle'||p.class==='bus') && (p.dist && p.dist < 1.2);
        const extra = hazard ? ' 注意、接近しています。' : '';
        const t = `${angleToClock(p.ang)}、${distSay? distSay+'、' : ''}${toJa(p.class)}。${extra}`;
        sayThrottle(`obj_${p.class}_${tagDir}`, t, hazard? 1200: 1700);
        said++;
      }
    });

    // 前方ROI可視化
    ctx.strokeStyle='rgba(255,255,255,.25)'; ctx.lineWidth=2;
    ctx.strokeRect(forwardROI.x, forwardROI.y, forwardROI.w, forwardROI.h);
  }

  async function detLoop(){
    if(!model){ ctx.clearRect(0,0,ov.width,ov.height); return; }
    try{ const preds=await model.detect(v); drawDetections(preds); }catch(e){ console.warn(e); }
    detTimer=setTimeout(detLoop, 600);
  }

  // FOVスライダー（距離補正のみ）
  const fovEl=document.getElementById('fov');
  fovEl.addEventListener('input',()=>{
    toast('FOV '+fovEl.value+'°'); sayThrottle('fov_notice','距離補正を更新しました。',1200);
    if(model) { model.detect(v).then(drawDetections).catch(()=>{}); }
  });

  // ==== Boot
  async function startAll(){
    document.getElementById('gate').style.display='none';
    await startCamera();
    toast('📦 モデル読込中…');
    const ok = await loadModelWithFallback();
    if(ok){ toast('✅ 準備完了'); detLoop(); }
    else { toast('⚠ モデル読み込み不可：カメラのみ動作（ネット/CDNを確認）'); }
  }
  document.getElementById('gateStart').onclick = ()=>{ startAll().catch(e=>console.error(e)); };
  document.getElementById('startBtn').onclick   = ()=>{ startAll().catch(e=>console.error(e)); };
})();
</script>
</body>
</html>
