<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>視覚ガイド（階段検出＋汎用ガード）</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui, -apple-system, Segoe UI, Roboto, 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif}
  #root{position:fixed;inset:0}
  video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
  #hud{position:fixed;left:0;right:0;bottom:0;background:#0b0b0cdd;backdrop-filter:blur(2px);padding:8px;display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button,select,input[type=range],label{font-size:14px}
  button{padding:8px 12px;border:0;border-radius:10px;background:#555;color:#fff;opacity:.6}
  button.ready{background:#2e7d32;opacity:1}
  button.stop{background:#c62828}
  #debug{position:fixed;left:8px;top:8px;right:8px;max-height:42vh;overflow:auto;background:#0008;border:1px solid #3a3; padding:6px;border-radius:8px;font:12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre-wrap}
  .badge{display:inline-block;padding:2px 6px;border-radius:6px;background:#111;border:1px solid #444;margin-right:6px}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:90px;background:#e53935;color:#fff;padding:8px 12px;border-radius:10px;font-weight:700;display:none}
  .toast.show{display:block}
</style>
</head>
<body>
<div id="root">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="view"></canvas>
</div>

<div id="debug"></div>
<div id="toast" class="toast">警告</div>

<div id="hud">
  <button id="btn" disabled>開始</button>
  <label><input type="checkbox" id="chkTactile"> 点字</label>
  <label><input type="checkbox" id="chkGuard" checked> 汎用ガード</label>
  <label><input type="checkbox" id="chkStair" checked> 階段検出</label>
  <label>最大件数 <input type="range" id="maxItems" min="1" max="8" value="4"></label>
  <span class="badge" id="badge">準備中…</span>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
<script src="https://docs.opencv.org/4.x/opencv.js" async></script>
<script>
const logEl = document.getElementById('debug');
function logOnce(key, ...args){ if(!logOnce._set) logOnce._set=new Set(); if(logOnce._set.has(key)) return; logOnce._set.add(key); const t=new Date().toLocaleTimeString(); logEl.textContent += `[${t}] ` + args.join(' ') + '\\n'; logEl.scrollTop = logEl.scrollHeight; }
function log(...args){ const t=new Date().toLocaleTimeString(); logEl.textContent += `[${t}] ` + args.join(' ') + '\\n'; logEl.scrollTop = logEl.scrollHeight; }
const toast = document.getElementById('toast');
function showToast(msg){ toast.textContent=msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), 1500); }

const badge = document.getElementById('badge');
const btn = document.getElementById('btn');
const chkTactile = document.getElementById('chkTactile');
const chkGuard = document.getElementById('chkGuard');
const chkStair = document.getElementById('chkStair');
const maxItems = document.getElementById('maxItems');

const video = document.getElementById('video');
const view = document.getElementById('view');
const ctx = view.getContext('2d');

let running=false, model=null, cvReady=false, allReady=false;

// ===== TFJS backend =====
(async()=>{
  try{
    await tf.setBackend('webgl').catch(async ()=>{ log('webgl backend failed -> cpu'); await tf.setBackend('cpu'); });
    await tf.ready(); log('TFJS backend:', tf.getBackend());
  }catch(e){ log('TFJS init error:', e); }
})();

// ===== OpenCV ready promise =====
const cvReadyPromise = new Promise(res=>{
  if (window.cv && cv.getBuildInformation) {
    cv['onRuntimeInitialized'] = ()=>{ cvReady=true; log('OpenCV ready'); res(); };
  } else {
    window.Module = { onRuntimeInitialized() { cvReady=true; log('OpenCV ready'); res(); } };
  }
});

async function initCamera(){
  const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment', width:{ideal:1280}, height:{ideal:720} }, audio:false });
  video.srcObject = stream; await video.play(); resize(); log('Camera initialized', video.videoWidth+'x'+video.videoHeight);
}
function resize(){ view.width = video.videoWidth || view.clientWidth; view.height = video.videoHeight || view.clientHeight; }
window.addEventListener('resize', resize);

// ===== TTS（クールダウン） =====
const READ_OVERRIDES = new Map([['方向','ほうこう'],['信号','しんごう'],['横断歩道','おうだんほどう'],['進行方向','しんこうほうこう'],['階段','かいだん']]);
const cooldownMs = 3000; let lastSpeakAt = {};
function normalizeReading(s){ for(const [k,v] of READ_OVERRIDES) s=s.replaceAll(k,v); return s; }
function speakThrottled(text, key){
  const now=Date.now();
  if (speechSynthesis.speaking) return;
  if (lastSpeakAt[key] && (now - lastSpeakAt[key] < cooldownMs)) return;
  lastSpeakAt[key]=now;
  try{ const u=new SpeechSynthesisUtterance(normalizeReading(text)); u.lang='ja-JP'; speechSynthesis.speak(u); }catch(e){}
}

// ===== Helper =====
function bearingLabel(cx, cy, W, H){ const dx=cx-W/2, dy=H/2-cy; let deg=(Math.atan2(dy,dx)*180/Math.PI+360)%360; const hour=Math.round(deg/30)||12; return `${hour}じ`; }
function centerAngleDeg(cx, cy, W, H){ const dx=cx-W/2, dy=H/2-cy; let deg=(Math.atan2(dy,dx)*180/Math.PI+360)%360; return deg; }
function estDistanceMeters(w,h,W,H){ const areaRatio=(w*h)/(W*H); return Math.min(10, Math.max(0.3, 0.6/Math.sqrt(Math.max(areaRatio,1e-6)))); }
const LABEL_JA = {'person':'人','bicycle':'自転車','car':'車','bus':'バス','motorcycle':'バイク','truck':'トラック','laptop':'ノートパソコン','mouse':'マウス','backpack':'リュックサック','traffic light':'信号機'};

// ===== 点字ブロック（軽量） =====
function detectTactileSimple(srcRGBA){
  if(!cvReady) return [];
  let gray=new cv.Mat(); cv.cvtColor(srcRGBA,gray,cv.COLOR_RGBA2GRAY); let mean=cv.mean(gray)[0]; gray.delete(); if(mean<40) return [];
  let rgb=new cv.Mat(); cv.cvtColor(srcRGBA,rgb,cv.COLOR_RGBA2RGB);
  let hsv=new cv.Mat(); cv.cvtColor(rgb,hsv,cv.COLOR_RGB2HSV); rgb.delete();
  let lo=new cv.Mat(hsv.rows,hsv.cols,hsv.type(),[18,140,120,0]); let hi=new cv.Mat(hsv.rows,hsv.cols,hsv.type(),[36,255,255,255]);
  let mask=new cv.Mat(); cv.inRange(hsv,lo,hi,mask); lo.delete(); hi.delete(); hsv.delete();
  const h=mask.rows,w=mask.cols; const floorH=Math.floor(h*0.4);
  let roiMask=new cv.Mat.zeros(h,w,cv.CV_8UC1); roiMask.roi(new cv.Rect(0,h-floorH,w,floorH)).setTo(new cv.Scalar(255));
  cv.bitwise_and(mask,roiMask,mask); roiMask.delete();
  let k=cv.Mat.ones(5,5,cv.CV_8U); cv.morphologyEx(mask,mask,cv.MORPH_OPEN,k); cv.morphologyEx(mask,mask,cv.MORPH_CLOSE,k); k.delete();
  let contours=new cv.MatVector(), hier=new cv.Mat(); cv.findContours(mask,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE); mask.delete(); hier.delete();
  let out=[]; for(let i=0;i<contours.size();i++){ let r=cv.boundingRect(contours.get(i)); const ar=(r.width*r.height)/(w*h); const aspect=r.width>r.height?r.width/(r.height+1e-6):r.height/(r.width+1e-6); if(ar>0.002 && ar<0.2 && aspect>1.2 && aspect<6.0){ out.push({x:r.x,y:r.y,w:r.width,h:r.height,label:'点字ブロック'}); } } contours.delete(); return out;
}

// ===== 階段検出（下半分：水平エッジが多数・等間隔に並ぶ） =====
function detectStairs(srcRGBA){
  if(!cvReady) return null;
  const W=srcRGBA.cols, H=srcRGBA.rows;
  const y0 = Math.floor(H*0.45), hh = Math.floor(H*0.55); // 下半分主体
  let roi = srcRGBA.roi(new cv.Rect(0, y0, W, Math.max(1, hh)));
  let g = new cv.Mat(); cv.cvtColor(roi, g, cv.COLOR_RGBA2GRAY);
  cv.equalizeHist(g,g);
  cv.GaussianBlur(g,g,new cv.Size(3,3),0);
  let edges = new cv.Mat(); cv.Canny(g, edges, 60, 120);

  // 水平ライン抽出
  let lines = new cv.Mat();
  cv.HoughLines(edges, lines, 1, Math.PI/180, 90);
  let angles = [];
  for(let i=0;i<lines.rows;i++){
    let theta = lines.data32F[i*2+1];
    // theta≈0 or pi（水平）を採用
    if(Math.min(Math.abs(theta), Math.abs(Math.PI-theta)) < (12*Math.PI/180)){
      angles.push(theta);
    }
  }

  let result = null;
  if(angles.length >= 6){ // 水平ラインが多い
    // 等間隔性をスコア化（累積投票を簡易に）
    // プロジェクション：y方向にエッジピクセル数を集計
    let hist = new Array(roi.rows).fill(0);
    for(let y=0;y<roi.rows;y++){
      for(let x=0;x<roi.cols;x++){
        if(edges.ucharPtr(y,x)[0]>0) hist[y]++;
      }
    }
    // 局所ピーク数
    let peaks = 0;
    for(let y=2;y<hist.length-2;y++){
      if(hist[y]>hist[y-1] && hist[y]>hist[y-2] && hist[y]>hist[y+1] && hist[y]>hist[y+2] && hist[y]> (0.15*W)){
        peaks++;
      }
    }
    if(peaks>=5){
      // 階段らしい → 全体矩形を返す
      result = {x:0, y:y0, w:W, h:hh, label:'階段'};
    }
  }

  g.delete(); edges.delete(); lines.delete(); roi.delete();
  return result;
}

// ===== 汎用衝突ガード =====
function detectPlanarObstacle(srcRGBA){
  if(!cvReady) return null;
  const W=srcRGBA.cols, H=srcRGBA.rows;
  let gray=new cv.Mat(); cv.cvtColor(srcRGBA,gray,cv.COLOR_RGBA2GRAY);
  let blur=new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(9,9), 0);
  let edges=new cv.Mat(); cv.Canny(blur, edges, 60, 120);
  const edgeRatio = cv.countNonZero(edges) / (W*H);
  let mean = new cv.Mat(); let stddev = new cv.Mat();
  cv.meanStdDev(blur, mean, stddev);
  const sigma = stddev.data64F[0];
  gray.delete(); mean.delete(); stddev.delete();
  // 低エッジ＆低分散で大きい面
  if(edgeRatio < 0.035 && sigma < 20){
    const cx = Math.floor(W*0.2), cy = Math.floor(H*0.2);
    const cw = Math.floor(W*0.6), ch = Math.floor(H*0.6);
    const roi = blur.roi(new cv.Rect(cx, cy, cw, ch));
    let m2=new cv.Mat(), s2=new cv.Mat(); cv.meanStdDev(roi, m2, s2);
    const sigma2 = s2.data64F[0]; m2.delete(); s2.delete(); roi.delete(); blur.delete(); edges.delete();
    if(sigma2 < 18) return {x:cx, y:cy, w:cw, h:ch, label:'正面の平面（壁/扉）'};
  }
  blur.delete(); edges.delete();
  return null;
}

function nearFieldGuard(stable, W, H){
  for(const d of stable){
    const bottom = d.y + d.h;
    const wide = d.w / W;
    const dist = estDistanceMeters(d.w, d.h, W, H);
    if(bottom > H*0.85 || (wide>0.55 && bottom>H*0.75) || dist < 1.0){
      return {hit:true, box:d, message:'すぐ前に障害物、注意'};
    }
  }
  return {hit:false};
}

let lastAreas = new Map();
function approachingGuard(stable){
  const now = performance.now();
  for(const d of stable){
    const key = d.label;
    const area = d.w*d.h;
    const prev = lastAreas.get(key);
    lastAreas.set(key, {area, time: now});
    if(prev){
      const dt = (now - prev.time)/1000;
      if(dt>0 && area > prev.area*1.5 && dt < 0.7){
        return {hit:true, box:d, message:`${d.label} が近づいています`};
      }
    }
  }
  return {hit:false};
}

// ===== 安定化 =====
let trackBuf = [];
function iou(a,b){ const x1=Math.max(a.x,b.x), y1=Math.max(a.y,b.y); const x2=Math.min(a.x+a.w,b.x+b.w), y2=Math.min(a.y+a.h,b.y+b.h); const inter=Math.max(0,x2-x1)*Math.max(0,y2-y1); const u=a.w*a.h + b.w*b.h - inter; return u>0? inter/u : 0; }
function stabilize(dets){
  const now=performance.now();
  dets.forEach(d=>{ let m=trackBuf.find(t=>t.label===d.label && iou(t,d)>0.5); if(m){ m.x=d.x; m.y=d.y; m.w=d.w; m.h=d.h; m.count=Math.min(m.count+1,5); m.ts=now; } else { trackBuf.push({...d,count:1,ts:now}); } });
  trackBuf = trackBuf.filter(t=> now - t.ts < 900);
  return trackBuf.filter(t=> t.count>=3);
}

// ===== メインループ =====
let offscreen = document.createElement('canvas'); let ofx = offscreen.getContext('2d');
let warnedModelNotReady = false;
let clearFrames = 0;

async function runLoop(){
  if(!running) return;
  resize();
  const W=view.width, H=view.height;
  ctx.drawImage(video,0,0,W,H);

  if(!model){
    if(!warnedModelNotReady){ logOnce('model-not-ready','モデル準備待ち…'); warnedModelNotReady=true; }
    requestAnimationFrame(runLoop); return;
  }

  const infW=320, infH=Math.max(1, Math.floor(H*(320/Math.max(1,W))));
  offscreen.width=infW; offscreen.height=infH;
  ofx.drawImage(video,0,0,infW,infH);

  let t0=performance.now();
  let detections=[];
  try{ detections = await model.detect(offscreen); }catch(e){ logOnce('detect-error','detect error:', e && e.message ? e.message : e); }
  detections = detections.filter(p=>p && p.score>=0.6).sort((a,b)=>b.score-a.score).slice(0, parseInt(maxItems.value,10));

  const scaleX=W/infW, scaleY=H/infH;
  let dets = detections.map(p=>{ let [x,y,w,h]=p.bbox; x*=scaleX; y*=scaleY; w*=scaleX; h*=scaleY; return {x,y,w,h,label:(LABEL_JA[p.class]||p.class)}; });

  if(chkTactile.checked && cvReady){
    try{ const src=cv.imread(view); const tacts=detectTactileSimple(src); dets=dets.concat(tacts); src.delete(); }
    catch(e){ logOnce('cv-error','opencv error:', e && e.message ? e.message : e); }
  }

  // === 階段検出 ===
  let stairBox = null;
  if(chkStair.checked && cvReady){
    try{ const src=cv.imread(view); const r=detectStairs(src); src.delete(); if(r) dets.push(r); }catch(e){}
  }

  const stable = stabilize(dets);

  // === 衝突ガード ===
  let danger = null;
  if(chkGuard.checked && cvReady){
    try{
      const src=cv.imread(view);
      const planar = detectPlanarObstacle(src);
      src.delete();
      if(planar){ danger = {type:'planar', box:planar, message:'正面に壁や扉があります'}; }
    }catch(e){ /* ignore */ }
    if(!danger){
      const nf = nearFieldGuard(stable, W, H);
      if(nf.hit) danger = {type:'near', box:nf.box, message:nf.message};
    }
    if(!danger){
      const ap = approachingGuard(stable);
      if(ap.hit) danger = {type:'approach', box:ap.box, message:ap.message};
    }
  }

  // 描画
  ctx.lineWidth=4; ctx.font = `${Math.max(16, Math.floor(W*0.032))}px system-ui`;
  stable.forEach(d=>{
    let color='rgba(0,255,0,.9)'; if(d.label==='点字ブロック') color='#ffa726'; if(d.label==='階段') color='#42a5f5';
    ctx.strokeStyle=color; ctx.fillStyle='rgba(0,0,0,.55)';
    ctx.strokeRect(d.x,d.y,d.w,d.h);
    const angle = bearingLabel(d.x+d.w/2,d.y+d.h/2,W,H);
    const dist = estDistanceMeters(d.w,d.h,W,H);
    const text = `${angle} ほうこう  ${d.label}  ${dist.toFixed(1)}m`;
    const tw = ctx.measureText(text).width + 10;
    ctx.fillRect(d.x, Math.max(0,d.y-24), tw, 24);
    ctx.fillStyle = (d.label==='点字ブロック') ? '#ffd27f' : (d.label==='階段' ? '#bbdefb' : '#9cff9c');
    ctx.fillText(text, d.x+5, d.y-6);
    if(d.label==='階段'){ speakThrottled(`まえ かいだん ちゅうい`, 'stairs'); }
  });

  // 危険描画＆音声
  let announcedDanger = false;
  if(danger){
    const b = danger.box;
    ctx.strokeStyle = '#ff5252'; ctx.lineWidth=6; ctx.strokeRect(b.x,b.y,b.w,b.h);
    showToast(danger.message);
    speakThrottled(danger.message, 'danger_'+danger.type);
    announcedDanger = true; clearFrames = 0;
  }

  // 5m安全アナウンス（危険なし＆中央±30°に5m未満なし）
  const centerSafe = !announcedDanger && (function(){
    for(const d of stable){
      const deg = centerAngleDeg(d.x+d.w/2, d.y+d.h/2, W, H);
      const offCenter = Math.min(Math.abs(deg-0), 360-Math.abs(deg-0));
      const dist = estDistanceMeters(d.w,d.h,W,H);
      if(offCenter <= 30 && dist < 5) return false;
    }
    return true;
  })();
  clearFrames = centerSafe ? Math.min(clearFrames+1, 999) : 0;
  if(clearFrames >= 6){ speakThrottled('しんこうほうこう 5メートル あんぜんです', 'clear_path'); clearFrames = 0; }

  const fps = (1000/(performance.now()-t0)).toFixed(1);
  badge.textContent = `FPS:${fps}  安定:${stable.length}`;

  if(running) requestAnimationFrame(runLoop);
}

// ===== 起動シーケンス =====
(async function bootstrap(){
  try{
    badge.textContent='カメラ起動中…（許可してください）'; await initCamera();
    badge.textContent='モデル読込中…'; model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
    badge.textContent='OpenCV初期化中…'; await cvReadyPromise;
    allReady = true; btn.disabled=false; btn.classList.add('ready');
    badge.textContent='準備完了：開始で実行（点字/ガード/階段はチェックでON）';
    log('準備完了。階段：水平エッジ多数・等間隔検出で警告します。');
  }catch(e){
    log('初期化エラー:', e); badge.textContent='エラー：上のログを確認';
  }
})();

btn.onclick = ()=>{
  if(!allReady){ logOnce('not-ready','準備中。ボタンが緑になるまで待機してください。'); return; }
  if(!running){ running=true; btn.textContent='停止'; btn.classList.add('stop'); requestAnimationFrame(runLoop); }
  else{ running=false; btn.textContent='開始'; btn.classList.remove('stop'); }
};
</script>
</body>
</html>
